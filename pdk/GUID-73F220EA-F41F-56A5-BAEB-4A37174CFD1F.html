<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Power Management"/>
<meta name="abstract" content="Describes the power management policies."/>
<meta name="description" content="Describes the power management policies."/>
<meta name="DC.Relation" scheme="URI" content="GUID-C6825C8F-8020-58CF-A09E-34558B1542DE.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-CFD2236E-7775-5532-89CD-7D0E1E219FD8.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-2F114BC9-9B5D-5989-9CF3-37A43377DC58.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-79B2CF91-FB95-5E7C-81CC-235A6A660D88.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-9573F7B9-76E9-5DCB-A498-C0DE59606911.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C6825C8F-8020-58CF-A09E-34558B1542DE.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Power Management</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2400576 id2400607 id2400622 id2400630 id2400650 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-CFD2236E-7775-5532-89CD-7D0E1E219FD8.html" title="Provides an overview of generic driver support.">Generic Driver Support</a> &gt; <a href="GUID-2F114BC9-9B5D-5989-9CF3-37A43377DC58.html" title="Provides the physical device drivers, called media drivers, and associated libraries that manage storage media hardware.">Media Drivers</a> &gt; <a href="GUID-79B2CF91-FB95-5E7C-81CC-235A6A660D88.html" title="The MMC Controller provides kernel extensions that manages access to the MultiMediaCard hardware on behalf of media drivers or any other device driver.">MMC Controller</a> &gt; <a href="GUID-9573F7B9-76E9-5DCB-A498-C0DE59606911.html" title="Describes the technology, architecture, and behaviour of the MMC Controller.">Concepts</a> &gt; <a href="GUID-C6825C8F-8020-58CF-A09E-34558B1542DE.html" title="This section describes the detailed structure and operation of the MMC Controller.">MMC Controller Operation</a> &gt; </div>
<h1 class="topictitle1">Power
Management</h1>
<div><p>Describes the power management policies. </p>

<p>The MMC Controller manages the power to the MultiMediaCard hardware.</p>

<div class="section" id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-C54927A1-8631-5DA0-9DDF-C399577B44C0"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-C54927A1-8631-5DA0-9DDF-C399577B44C0"><!-- --></a><h2 class="sectiontitle">Normal power
up and power down handling</h2> <p>Before card commands can be issued to
a card, three operations are required: </p>
 <ul>
<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-6E4702E7-FAC7-5AFE-BB83-73EAE2774E71"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-6E4702E7-FAC7-5AFE-BB83-73EAE2774E71"><!-- --></a><p>power must be applied
to the card, i.e. VDD must be turned on </p>
 </li>

<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-694FED8E-108D-564F-BDDD-078C1F91627D"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-694FED8E-108D-564F-BDDD-078C1F91627D"><!-- --></a><p>any requirement from
the power model must be set, e.g. requesting a necessary system clock </p>
 </li>

<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-43728A53-CD2B-565A-B436-E3C59B61710E"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-43728A53-CD2B-565A-B436-E3C59B61710E"><!-- --></a><p>the clock to the card
interface must be switched on. </p>
 </li>

</ul>
 <p>All three operations are performed as part of the <a href="GUID-B5193656-9819-3E00-A335-EEF1726115A5.html#GUID-B5193656-9819-3E00-A335-EEF1726115A5__GUID-D8D3CFDC-5292-3853-8618-5D3A21F5C4D7"><span class="apiname">DMMCStack::CIMInitStackSM()</span></a> state
machine function which then issues the sequence of commands involved in performing
the <samp class="codeph">CIM_UPDATE_ACQ</samp> macro to initialize a card stack. </p>
 <p>There
are two cases: </p>
 <ul>
<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-EB3AC768-EF05-5BED-867F-E0C65E2AB43E"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-EB3AC768-EF05-5BED-867F-E0C65E2AB43E"><!-- --></a><p>Local drive requests,
i.e. those originating from a media driver - if the card is not fully powered
up when such a request is received, then the local media device driver automatically
precedes the request with an instruction to the controller to power up the
card. This results in <a href="GUID-45B97680-1756-3559-8A2D-2F2E851AD6A7.html#GUID-45B97680-1756-3559-8A2D-2F2E851AD6A7__GUID-C0E6CF87-8E8B-3B14-9B7E-302E3688CFA5"><span class="apiname">DMMCSocket::InitiatePowerUpSequence()</span></a> being
called, which in turn invokes the <a href="GUID-B5193656-9819-3E00-A335-EEF1726115A5.html#GUID-B5193656-9819-3E00-A335-EEF1726115A5__GUID-D8D3CFDC-5292-3853-8618-5D3A21F5C4D7"><span class="apiname">DMMCStack::CIMInitStackSM()</span></a> state
machine function. </p>
 <p>Once the MultiMediaCard stack has been initialized,
the MultiMediaCard controller calls <a href="GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB.html#GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB__GUID-0FEFB701-D37A-320F-A49B-6126EF608BF7"><span class="apiname">DPBusSocket::PowerUpSequenceComplete()</span></a> to
signal the completion of initialization back to the local media driver, and
this can then continue to open a media driver and continue with the original
request. </p>
 <p>This automatic re-powering of the card applies in all situations
which can lead to the card not being powered: media change, machine power
down, card inactivity timeout, VDD power problem etc. In most cases, the process
of restoring power results in the closure of any existing media driver and
a new one opened. As the kernel thread used to perform controller requests
is able to block, this means that no special mechanism is necessary to allow
for this potential long-running power up sequence prior to a request on the
device. </p>
 </li>

<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-D8AA1127-B8B2-52BB-A242-A487A875B908"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-D8AA1127-B8B2-52BB-A242-A487A875B908"><!-- --></a><p>Requests not originating
via a local media device driver, for example device drivers for I/O cards
- if the MultiMediaCard stack is not initialized when the client submits a
session, then the MultiMediaCard controller automatically precedes the request
with a call to the <a href="GUID-B5193656-9819-3E00-A335-EEF1726115A5.html#GUID-B5193656-9819-3E00-A335-EEF1726115A5__GUID-D8D3CFDC-5292-3853-8618-5D3A21F5C4D7"><span class="apiname">DMMCStack::CIMInitStackSM()</span></a> state machine
function. </p>
 </li>

</ul>
 <p>The MultiMediaCard controller will normally be configured with an
inactivity timer. If a given period elapses where there is no bus activity,
then the controller automatically turns off the card clock, removes any power
requirements on the power model, and then removes power from the cards. This
is the bus power down sequence. The length of this inactivity timeout period
is set in the platform specific layer as part of porting the controller, and
can be disabled completely if required; see the reference to porting the <a href="GUID-E55B4FE5-517C-5A23-8ACA-E28EE202330B.html#GUID-E55B4FE5-517C-5A23-8ACA-E28EE202330B__GUID-99529E84-17E1-5F23-9A1B-EBE3976D9B14">PsuInfo()</a> function
as part of implementing the <a href="GUID-E55B4FE5-517C-5A23-8ACA-E28EE202330B.html#GUID-E55B4FE5-517C-5A23-8ACA-E28EE202330B__GUID-3A1E907E-A74D-59CB-A1D6-FEF4849EF2D5">DMMCPsu
derived class</a>. </p>
 <p>Clients of the controller do not need to worry
about re-initializing the stack following such a power down as the controller
does this automatically. </p>
 <p>In the event of a PSU voltage check failure,
the controller performs the bus power down sequence. It will not re-power
the problem card and will expect it to be removed. </p>
 <p>The power model
calls <a href="GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB.html#GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB__GUID-F037A26D-0C72-364F-B3CD-87B9FF22AAB1"><span class="apiname">DPBusSocket::DoPowerDown()</span></a> when the machine is about
to be normally turned off (due to the off key being pressed or keyboard/touch
screen inactivity). This leads to the function <a href="GUID-B5193656-9819-3E00-A335-EEF1726115A5.html#GUID-B5193656-9819-3E00-A335-EEF1726115A5__GUID-CF271B2B-A515-3DB7-AD52-8138BAFF901C"><span class="apiname">DMMCStack::PowerDownStack()</span></a> being
called resulting in the bus power down sequence. </p>
 <p>When the machine
is powered back up after a normal power off, the power model calls <a href="GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB.html#GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB__GUID-C4EC4C74-24CE-3A55-B63F-30E32DB0259A"><span class="apiname">DPBusSocket::DoPowerUp()</span></a>.
However, the controller normally does not power up the bus, but waits for
the next request from one of its clients before doing so. The only exception
is where a card power up sequence was interrupted by the machine being turned
off. </p>
 </div>

<div class="section" id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-BBD2119B-99D6-56A1-B42F-EE2953D88898"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-BBD2119B-99D6-56A1-B42F-EE2953D88898"><!-- --></a><h2 class="sectiontitle"> Emergency
power down</h2> <p>In an emergency power down situation, for example, where
a battery is in a critically low power state, the MultiMediaCard controller
performs the normal bus power down sequence as this is not a lengthy operation.
The power model calls <a href="GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB.html#GUID-C988CAE6-9073-3851-A0B0-5479D1A34CFB__GUID-A893EB7B-289E-36DB-B249-CA8DB81EEAE2"><span class="apiname">DPBusSocket::DoEmergencyPowerDown()</span></a>,
which results in a call to <a href="GUID-B5193656-9819-3E00-A335-EEF1726115A5.html#GUID-B5193656-9819-3E00-A335-EEF1726115A5__GUID-CF271B2B-A515-3DB7-AD52-8138BAFF901C"><span class="apiname">DMMCStack::PowerDownStack()</span></a>. </p>
 <p>However,
there is always a risk that a block being written to a card may become corrupt.
The solution to this problem lies in the hardware architecture. Two possible
solutions are: </p>
 <ul>
<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-02EF5215-2740-5DE9-9418-0BC44ED6051A"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-02EF5215-2740-5DE9-9418-0BC44ED6051A"><!-- --></a><p>to provide enough early
warning of power being removed before the battery level becomes too low for
card operation. For example, a catch mechanism on a battery door, making it
slow to remove. This would provide sufficient time for any write operation
in progress to be terminated at the next block boundary before the power supply
is lost. </p>
 <p>Note, however, that the media driver fails any operations
involving write operations to a card when the battery level is becoming dangerously
low, so in general, we are only talking about unexpected battery removal. </p>
 </li>

<li id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-FFC11D23-7187-5095-9D18-CF01D85F7A1A"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-FFC11D23-7187-5095-9D18-CF01D85F7A1A"><!-- --></a><p>to provide a backup
battery so that the failing write operation can be re-retried once a good
battery level has been restored. </p>
 </li>

</ul>
 <p>Even with such mechanisms in place, if power is removed in the middle
of a multi-block write operation, then some blocks will contain new data while
others will still contain old data. </p>
 </div>

<div class="section" id="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-8681487C-DD00-58A3-9BFB-8F62A74268C9"><a name="GUID-73F220EA-F41F-56A5-BAEB-4A37174CFD1F__GUID-8681487C-DD00-58A3-9BFB-8F62A74268C9"><!-- --></a><h2 class="sectiontitle">Media change</h2> <p>When
a door open event is detected by the MultiMediaCard controller, it attempts
to remove power from a card as soon as possible. Power is not removed immediately
if a bus operation is in progress as powering down a card in the middle of
writing a block could leave the block corrupted. </p>
 <p>Power is only removed
from a card immediately a door open event occurs if there are no sessions
queued by clients on the controller. If one or more sessions are queued then
these are allowed to complete, with power being removed once the last session
has completed. Any attempt to engage a new session while the door is open
fails with <a href="GUID-51298FCE-7857-39F8-BFAB-49AF5556D0CC.html"><span class="apiname">KErrNotReady</span></a>. </p>
 <p>To prevent a card becoming
corrupt because of attempted removal during a write operation, then it is
important that the door mechanism and circuitry gives enough early warning
of a potential card removal before the card is actually removed. This is to
provide sufficient time for any write operation in progress to proceed to
the next block boundary before the card is removed. </p>
 <p>Once the door
is closed again, then new sessions can be engaged and power can be re-applied
to the card by the controller. However, power is only restored by the controller
in response to a client request. The Controller does not automatically re-power
a card to resume an operation interrupted by a door open event, no matter
what operation was in progress when the door opened. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-C6825C8F-8020-58CF-A09E-34558B1542DE.html" title="This section describes the detailed structure and operation of the MMC Controller.">MMC Controller Operation</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
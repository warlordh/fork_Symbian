<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Surface Update Component Overview"/>
<meta name="abstract" content="Each graphics composition surface has at least two interested stakeholders: the process responsible for drawing and maintaining the content and the composition engine, which uses the surface for creating the display. When one of the stakeholders does something to the surface, it usually means that another stakeholder needs to do something too. The Surface Update component provides a channel for the stakeholders to inform each other of changes."/>
<meta name="description" content="Each graphics composition surface has at least two interested stakeholders: the process responsible for drawing and maintaining the content and the composition engine, which uses the surface for creating the display. When one of the stakeholders does something to the surface, it usually means that another stakeholder needs to do something too. The Surface Update component provides a channel for the stakeholders to inform each other of changes."/>
<meta name="DC.Relation" scheme="URI" content="GUID-81A0A2E9-4BB9-58BF-B2D3-08098E7E9C7C.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-975CBC70-81E6-5FA2-80CE-88DD2ABE9595.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-63CB6C7E-44EC-5D0B-A37D-FE78F7D76592.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-81A0A2E9-4BB9-58BF-B2D3-08098E7E9C7C.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-D2ECF215-B53C-5659-BA86-5B658C0C2D2F.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-ADA8CECB-0E70-5B9C-8F36-0714AAF0CD13.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-55EF3CEB-AF3E-5A32-96F3-F146D1A06C8F.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-63CB6C7E-44EC-5D0B-A37D-FE78F7D76592.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Surface Update Component Overview</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2384330 id2387228 id2387294 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-975CBC70-81E6-5FA2-80CE-88DD2ABE9595.html">Graphics Guide</a> &gt; <a href="GUID-63CB6C7E-44EC-5D0B-A37D-FE78F7D76592.html" title="The Graphics Composition collection is a key part of ScreenPlay. The collection is made up of components that are concerned with composition. This is the process of putting together the output elements from various different sources to create the display that the viewer sees on the screen.">Graphics Composition Collection</a> &gt; <a href="GUID-81A0A2E9-4BB9-58BF-B2D3-08098E7E9C7C.html" title="The Surface Update component provides a communication mechanism between the composition engine and its clients.">Surface Update Component</a> &gt; </div>
<h1 class="topictitle1">Surface Update Component Overview</h1>
<div><p>Each graphics composition surface has at least two interested stakeholders: the process responsible for drawing and maintaining the content and the composition engine, which uses the surface for creating the display. When one of the stakeholders does something to the surface, it usually means that another stakeholder needs to do something too. The Surface Update component provides a channel for the stakeholders to inform each other of changes. </p>
<p> <strong>Variant</strong>: <a href="GUID-D93978BE-11A3-5CE3-B110-1DEAA5AD566C.html" title="This topic provides an introduction to ScreenPlay and its architecture. ScreenPlay is a new graphics architecture, introduced in Symbian^3 (S^3). ScreenPlay enables device creators to take advantage of improved software performance, hardware acceleration and third party graphics engines. ScreenPlay is sometimes known as the New Graphics Architecture (NGA).">ScreenPlay</a>. <strong>Target audience</strong>: Device creators. </p>
 <div class="section"><h2 class="sectiontitle">Purpose</h2> <p>The Surface Update component provides a communication channel interface for use by components that render graphics content to <a href="GUID-ADA8CECB-0E70-5B9C-8F36-0714AAF0CD13.html" title="This topic provides an introduction to graphics composition surfaces, which are usually simply called surfaces. Surfaces are pixel buffers that have associated metadata describing the width, height, stride and pixel format and are used as input to the composition components. Surfaces can be multi-buffered and are identified by a 128-bit identifier (called the surface ID).">composition surfaces</a>. Examples of such components are <a href="GUID-DC8BFEF5-DA50-52DA-8CE2-5729A4A005F6.html" title="EGL is an interface between EGL client APIs (such as OpenGL ES and OpenVG) and an underlying native platform window system. EGL is independent of definitions and concepts specific to any native window system or rendering API.">EGL</a>, the <a href="GUID-D1F29744-EB92-5811-A735-B0BC1B352ED5.html" title="This topic describes the Video Renderer component and is aimed at video controller and video adaptation developers who want to take advantage of rendering to graphics surfaces.">video renderer (DevVideo)</a>, the <a href="GUID-36C3A2FD-F4F9-5B8C-91B7-40C29B3D2224.html">camera viewfinder (ECam)</a> and <a href="GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87.html" title="Render stages are ROM-based plug-ins to the Window Server render stage framework. They can be chained to form a rendering pipeline, which takes the draw operations that are produced by the Window Server and ultimately passes them to the UI surface. Render stages can selectively filter, modify, or redirect the draw operation stream, as requiredâ€”for example, to perform transition effects (TFX).">render stages</a>. This is illustrated in the following diagram. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-4916D92E-A639-52FD-9688-181216E0BD9E"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-4916D92E-A639-52FD-9688-181216E0BD9E"><!-- --></a><span class="figcap">Figure 1. 
             Surface Update component use case model 
          </span> <img src="GUID-C830420C-FBBD-5265-8746-7690C0ADCE81_d0e280208_href.png"/></div>
 <p>The client renders the graphics content to a buffer within the surface and then sends a request for composition. The request includes the surface ID, the ID of the current buffer within the surface and optionally the following: </p>
 <ul><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-A681DFDE-FC19-5200-B7A2-0F83170B4100"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-A681DFDE-FC19-5200-B7A2-0F83170B4100"><!-- --></a><p>The number of the screen on which the surface is to be displayed. Alternatively, the <samp class="codeph">KAllScreens</samp> constant can be used to indicate that the request should be broadcast to all screens. This is called a <a href="GUID-D2ECF215-B53C-5659-BA86-5B658C0C2D2F.html" title="Global surface updates are surface composition update commands that are submitted to all displays rather than to a single one. This causes the Surface Update Server to broadcast the update to all of the registered composition engine instances. Each of these then determines whether the surface is displayed on its associated screen and if so, forces an update.">global surface update</a> and its use is encouraged. It makes the client code simpler because it does not need to be concerned with which screen a surface is currently visible on. Note that you must not mix global updates with updates to specific screens within a single session. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-AE975674-48C9-54BB-B1F2-F246CF70DA62"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-AE975674-48C9-54BB-B1F2-F246CF70DA62"><!-- --></a><p>The region of the surface that has changed. This is sometimes referred to as the <strong>dirty rectangle</strong>. If the client does not specify this, the whole surface is recomposed. </p>
 </li>
 </ul>
 <p>The client can request notification of the following composition-related events: </p>
 <ul><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-2BECDC59-1594-58B0-9F5C-7AD2D9150D4C"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-2BECDC59-1594-58B0-9F5C-7AD2D9150D4C"><!-- --></a><p>The buffer has become available for rendering. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-2EA4C005-B42B-5DA4-8522-7F63E6DC7FD6"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-2EA4C005-B42B-5DA4-8522-7F63E6DC7FD6"><!-- --></a><p>The buffer has been displayed for the first time after the update was submitted. This notification is accompanied by timestamp information. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-FD042426-4B77-5421-809F-F554553E0F6C"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-FD042426-4B77-5421-809F-F554553E0F6C"><!-- --></a><p>The buffer has been displayed a certain number of times. This can be used to ensure that each frame gets displayed for at least a given period of time. </p>
 </li>
 </ul>
 </div>
 <div class="section"><h2 class="sectiontitle">Architecture</h2> <p>The Surface Update component is an adaptation component, which means that it can be replaced by device creators to suit the exact hardware. The reference implementation consists of the Surface Update Server and its client-side API. The Surface Update Server runs within the Window Server process along with the composition engine. The Surface Update Server uses the standard Symbian client/server model for Inter Process Communication (IPC) to communicate with clients and Inter Thread Communication (using active objects and semaphores) to communicate with the composition engine. </p>
 <p>The client sends requests for composition through the <strong>command channel</strong> and the composition engine sends notification messages through the <strong>notification channel</strong>. </p>
 <p>The following diagram shows communication between the client, Surface Update server and composition engine. The composition engine is shown as a single component, although it can be implemented as multiple components. For example, the <a href="GUID-8FE41C9A-8171-58A2-A808-17B81E79B11F.html" title="This section describes the OpenWF Composition (OpenWF-C) components. OpenWF-C is an open standard for layered graphics composition developed by the Khronos Group.">OpenWF-C implementation</a> consists of the OpenWF-C Support component and the OpenWF-C Engine component. The Surface Update Server in fact communicates with the OpenWF-C Support component, which in turn communicates with the OpenWF-C Engine. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-371C3037-3D9B-5647-A77B-B7624DFD66E8"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-371C3037-3D9B-5647-A77B-B7624DFD66E8"><!-- --></a><span class="figcap">Figure 2. 
             The Surface Update Server, showing IPC and ITC 
          </span> <img src="GUID-26354520-8E9C-58B8-81E7-001EDE9AB77F_d0e280281_href.png"/></div>
 <p>Some key points to note include: </p>
 <ul><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-7054554A-9788-55F0-B8E5-9DF2C2B87FDC"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-7054554A-9788-55F0-B8E5-9DF2C2B87FDC"><!-- --></a><p>The composition engine is a device-specific adaptation that may delegate some of its functionality (such as composing hardware-rendered surfaces) to a GPU or display controller. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-38CC81F2-A85D-50E3-B450-F205618AB533"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-38CC81F2-A85D-50E3-B450-F205618AB533"><!-- --></a><p>There is a composition engine instance for each internal screen and external screen connection point on the device. Each composition engine must be registered with the Surface Update Server at startup. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-E08F7A3A-46BB-51FF-B9F2-5060DBB115E4"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-E08F7A3A-46BB-51FF-B9F2-5060DBB115E4"><!-- --></a><p>Each composition engine instance has a unique 32-bit priority number, which represents the relative priority of its associated screen. The higher the number, the higher the priority of the screen. The composition engine instance passes this to the Surface Update Server at registration. The Surface Update Server adds the priority value to its priority list. After it is set up, the priority list is fixed and does not change when a screen becomes unavailableâ€”for example, because it is put on standby or an external screen is disconnected. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-51786E9E-36DC-5459-BEF9-B3A59B8A58E0"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-51786E9E-36DC-5459-BEF9-B3A59B8A58E0"><!-- --></a><p>Each composition engine instance incorporates its own thread within the Window Server process. However, the external interface is accessed directly from the thread that makes the call. This means that <a href="GUID-229099A4-EE8A-3EA7-8AA3-74ACE34ED1CD.html#GUID-229099A4-EE8A-3EA7-8AA3-74ACE34ED1CD__GUID-64037182-167B-360C-B210-65B0861D4300"><span class="apiname">MCompositionSurfaceUpdate::ContentUpdated()</span></a> is called from the Surface Update Server thread. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-60224A78-8433-579C-9075-B8AFCD9D1924"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-60224A78-8433-579C-9075-B8AFCD9D1924"><!-- --></a><p>The Window Server's main thread is a client of the Surface Update Server. Although it is running in the same process as the Surface Update Server, it uses <a href="GUID-FAFD23EB-90EF-3F0C-BAB3-74FEC8DF0E06.html"><span class="apiname">RSurfaceUpdateSession</span></a> in exactly the same way as a client in a separate process. </p>
 </li>
 </ul>
 <p>The following diagram provides a more detailed view of the architecture. Notice that there is a composition engine thread for each screen. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-C3E32B28-5E21-52AD-9065-EE4861302882"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-C3E32B28-5E21-52AD-9065-EE4861302882"><!-- --></a><span class="figcap">Figure 3. 
             Surface Update Server class diagram 
          </span> <img src="GUID-2FE3BDE7-8782-5026-9B90-D96B77197498_d0e280328_href.png"/></div>
 <p>Do not confuse the Surface Update Server with the <a href="GUID-55EF3CEB-AF3E-5A32-96F3-F146D1A06C8F.html" title="The Surface Manager is responsible for creating graphics composition surfaces (called surfaces) in system memory and controlling access to them.">Surface Manager</a>. The Surface Manager creates, deletes and manages access to the surface data, whereas the Surface Update Server is concerned with communicating the fact that surface data has changed. </p>
 </div>
 <div class="section"><h2 class="sectiontitle">The Surface Update client API</h2> <p>Here is a simplified <a href="GUID-FAFD23EB-90EF-3F0C-BAB3-74FEC8DF0E06.html"><span class="apiname">RSurfaceUpdateSession</span></a> declaration showing only the key functions. </p>
 <pre class="codeblock" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-AFEB594E-6C2A-55CF-8150-E2D14AB06AA3"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-AFEB594E-6C2A-55CF-8150-E2D14AB06AA3"><!-- --></a>class RSurfaceUpdateSession : public RSessionBase
    {
public:
    IMPORT_C RSurfaceUpdateSession();

    IMPORT_C TInt Connect(TInt aMessageSlots = KDefaultMessageSlot);

    IMPORT_C void NotifyWhenAvailable(TRequestStatus&amp; aStatus); 
    
    IMPORT_C void NotifyWhenDisplayed(TRequestStatus&amp; aStatus, TTimeStamp&amp; aTimeStamp);
    
    IMPORT_C void NotifyWhenDisplayedXTimes(TInt aCount, TRequestStatus&amp;  aStatus);
   
    IMPORT_C void CancelAllUpdateNotifications();
        
    IMPORT_C TInt SubmitUpdate(TInt aScreen, const TSurfaceId&amp; aSurfaceId, TInt aBuffer, 
                        const TRegion* aDirtyRegion = NULL);
};</pre>
 <p>To use the API: </p>
 <a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-0899998C-9C40-5C19-B3F7-C44DCF1ECA80"><!-- --></a><ol id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-0899998C-9C40-5C19-B3F7-C44DCF1ECA80"><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-EEDF1B21-76B3-59E3-81BE-0E69EC0FFBA4"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-EEDF1B21-76B3-59E3-81BE-0E69EC0FFBA4"><!-- --></a><p> <strong>Connect to the Surface Update Server</strong>. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-01857F39-49E9-5536-BD2A-7C0935B7034E"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-01857F39-49E9-5536-BD2A-7C0935B7034E"><!-- --></a><p> <strong>Set up one or more notification requests</strong>. </p>
 <p>This part of the process is optional. You need to do it only if the client wants to know when the composition engine has used the data on the surface. To set up a request, call one of the <samp class="codeph">NotifyWhen...()</samp> functions. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-C363F3D1-2618-539C-BB9F-18CB6D845932"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-C363F3D1-2618-539C-BB9F-18CB6D845932"><!-- --></a><p> <strong>Send notification that your surface data has been updated</strong>. </p>
 <p>Call the <samp class="codeph">SubmitUpdate()</samp> function to send a message to the Surface Update Server that there is new data on the specified surface. The message contains the surface ID, the buffer number and the number of the screen on which the surface is displayed or a constant that indicates that the request should be broadcast to all screens (this is called a <a href="GUID-D2ECF215-B53C-5659-BA86-5B658C0C2D2F.html" title="Global surface updates are surface composition update commands that are submitted to all displays rather than to a single one. This causes the Surface Update Server to broadcast the update to all of the registered composition engine instances. Each of these then determines whether the surface is displayed on its associated screen and if so, forces an update.">global surface update</a>). The message can also specify the region of the surface that has changed. This allows the composition engine to ignore parts that have not changed. Before it sends the update, the function sends all of the notification requests that the client has set up. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-FB6BF6C6-6BDF-5DBF-96E9-7BB4E6D1D039"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-FB6BF6C6-6BDF-5DBF-96E9-7BB4E6D1D039"><!-- --></a><p> <strong>Wait for notifications from the Surface Update Server</strong>. </p>
 <p>If the client requests notification(s), it must wait (<samp class="codeph">User::WaitForRequest()</samp>) for the notification to arrive. However, clients normally use active objects and the Active Scheduler to handle the wait rather than calling <samp class="codeph">User::WaitForRequest()</samp> directly. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-2014F9B1-29B2-570D-BB9A-C7EB42EFBFF6"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-2014F9B1-29B2-570D-BB9A-C7EB42EFBFF6"><!-- --></a><p> <strong>Close the connection</strong>. </p>
 <p>If your client is still waiting for a notification you must call <samp class="codeph">CancelAllUpdateNotifiations()</samp> before closing the connection, otherwise the client thread panics. </p>
 </li>
 </ol>
 <p><strong>Example </strong> </p>
 <p>Here is a snippet of test code which illustrates the process of setting up notification requests before submitting an update. This piece of code results in four messages being sent to the Surface Update Server in <samp class="codeph">SubmitUpdate()</samp>: </p>
 <pre class="codeblock" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-ECFF2218-BF5D-54B2-84F1-BCC80AA5AE26"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-ECFF2218-BF5D-54B2-84F1-BCC80AA5AE26"><!-- --></a>TRequestStatus statusAvailable = KRequestPending ;
TRequestStatus statusDisplayed = KRequestPending ;
TRequestStatus statusDisplayedXTimes = KRequestPending ;

TTimeStamp timeStamp ; 
    
session.NotifyWhenAvailable( statusAvailable ) ;    
session.NotifyWhenDisplayed( statusDisplayed, timeStamp ) ;    
session.NotifyWhenDisplayedXTimes( 10, statusDisplayedXTimes ) ;    

err = session.SubmitUpdate( screen, surface, buffer, &amp;region ) ;
        
User::WaitForRequest( statusAvailable ) ;
User::WaitForRequest( statusDisplayed ) ;
User::WaitForRequest( statusDisplayedXTimes ) ;
</pre>
 <p> <em>Notes</em>: </p>
 <ul><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-E992F13D-4628-561B-A7A4-D2723FA06482"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-E992F13D-4628-561B-A7A4-D2723FA06482"><!-- --></a><p>Because this is test code and to avoid complexity, this example calls <samp class="codeph">User::WaitForRequest()</samp> directly rather than using active objects. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-7B0616B5-2978-5C0F-9DA8-1A4C2874E950"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-7B0616B5-2978-5C0F-9DA8-1A4C2874E950"><!-- --></a><p>In some hardware configurations where composition and display are fast, the buffer available and first displayed notifications may occur very close together for single-buffered surfaces. You should then use only one of these notifications at a time. </p>
 </li>
 </ul>
 </div>
 <div class="section"><h2 class="sectiontitle">Sequence diagrams</h2> <p>These sequence diagrams primarily illustrate the protocol linking the sending of the buffers and notification. For simplicity some detail is omitted. For example, the client typically renders to the buffer before sending it to the composition engine. This is not shown. Similarly the diagrams omit detail from the composition engine and some omit the Surface Update Server altogether. In addition, they assume that a specific screen number is specified. When global surface updates are in use, the sequence is more complex and is described in <a href="GUID-D2ECF215-B53C-5659-BA86-5B658C0C2D2F.html" title="Global surface updates are surface composition update commands that are submitted to all displays rather than to a single one. This causes the Surface Update Server to broadcast the update to all of the registered composition engine instances. Each of these then determines whether the surface is displayed on its associated screen and if so, forces an update.">Global Surface Updates</a>. </p>
 <p><strong>Surface buffer availability: single-buffered surface </strong> </p>
 <p>When using a single-buffered surface, the client typically does the following: </p>
 <a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-369D1CE5-DCDA-5764-9D72-6BF28BAEA5A5"><!-- --></a><ol id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-369D1CE5-DCDA-5764-9D72-6BF28BAEA5A5"><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-61EEC7A6-A561-50E0-8EB2-2D80944D1A4F"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-61EEC7A6-A561-50E0-8EB2-2D80944D1A4F"><!-- --></a><p>Render the graphics content to the buffer. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-FF4A8850-3E85-5A21-B155-1F559F50240B"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-FF4A8850-3E85-5A21-B155-1F559F50240B"><!-- --></a><p>Call <samp class="codeph">RSurfaceUpdateSession::NotifyWhenAvailable()</samp>. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-4108376B-5F0E-5C22-8654-F74663D61B97"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-4108376B-5F0E-5C22-8654-F74663D61B97"><!-- --></a><p>Call <samp class="codeph">RSurfaceUpdateSession::SubmitUpdate()</samp>. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-A7523952-6551-542D-B501-604764F16D30"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-A7523952-6551-542D-B501-604764F16D30"><!-- --></a><p>Wait for notification that the buffer is available before rendering further content to it and repeating the cycle for as long as necessary. </p>
 </li>
 </ol>
 <p>This is shown in the following diagram. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-6A62814B-0493-5E94-9D26-0AC2897B1E4E"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-6A62814B-0493-5E94-9D26-0AC2897B1E4E"><!-- --></a><span class="figcap">Figure 4. 
             Single-buffered surface availability 
          </span> <img src="GUID-28222243-1531-524F-81A7-070FF6E98C4C_d0e280515_href.png"/></div>
 <p>Notice that the notification signal is issued to the client immediately after the buffer has been consumed by the composition engine. When single buffers are used, tearing artefacts are always a risk. Therefore double-buffered surfaces are often used. </p>
 <p><strong>Surface buffer availability: double-buffered surface </strong> </p>
 <p>When double-buffering is used, the client renders to one buffer (called <em>A</em> in this example) while the other buffer (<em>B</em>) is on the screen and vice versa. In order for this to work correctly and to be free of tearing artefacts, the client must use the following sequence: </p>
 <a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-E45EC80D-1742-5699-9B84-E91D966718DA"><!-- --></a><ol id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-E45EC80D-1742-5699-9B84-E91D966718DA"><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-DA98CD3A-77DB-5AB2-9DCF-F85516D493C1"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-DA98CD3A-77DB-5AB2-9DCF-F85516D493C1"><!-- --></a><p>Render the graphics content to buffer <em>A</em>, and call <samp class="codeph">NotifyWhenAvailable()</samp> followed by <samp class="codeph">SubmitUpdate()</samp> for buffer <em>A</em>. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-1F750734-E797-5BD9-948D-392643F6F4B1"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-1F750734-E797-5BD9-948D-392643F6F4B1"><!-- --></a><p>Render the graphics content to buffer <em>B</em>, and call <samp class="codeph">NotifyWhenAvailable()</samp> followed by <samp class="codeph">SubmitUpdate()</samp> for buffer <em>B</em>. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-8C0526D0-A7D2-5E6C-964A-7BC1E67817D5"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-8C0526D0-A7D2-5E6C-964A-7BC1E67817D5"><!-- --></a><p>Wait for notification that buffer <em>A</em> is available. When it becomes available, render further content to it and call <samp class="codeph">NotifyWhenAvailable()</samp> followed by <samp class="codeph">SubmitUpdate()</samp> for buffer <em>A.</em>  </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-60312FB1-9EF9-54B5-85F0-121F0E497CDC"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-60312FB1-9EF9-54B5-85F0-121F0E497CDC"><!-- --></a><p>Wait for notification that buffer <em>B</em> is available. When it becomes available, render further content to it and call <samp class="codeph">NotifyWhenAvailable()</samp> followed by <samp class="codeph">SubmitUpdate()</samp> for buffer <em>B.</em>  </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-5CB0B8BB-AA69-5C35-9774-A158DDD93072"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-5CB0B8BB-AA69-5C35-9774-A158DDD93072"><!-- --></a><p>Repeat steps 3 and 4 for as long as required. </p>
 </li>
 </ol>
 <p>This is shown in the next diagram. After sending the first two buffers to the composition engine, the client waits for notification before sending a further buffer. The composition engine always returns notification after receiving a new buffer even if an error condition is detected. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-9FE30A58-B4D4-5E0A-907E-63586E5D8529"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-9FE30A58-B4D4-5E0A-907E-63586E5D8529"><!-- --></a><span class="figcap">Figure 5. 
             Double-buffered surface availability 
          </span> <img src="GUID-9CDB7D27-B4C9-593B-8C67-0335A868BAC0_d0e280616_href.png"/></div>
 <p> <em>Notes</em>: </p>
 <ul><li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-6C575BD0-C7B5-525B-AB28-05A6F9ADEE76"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-6C575BD0-C7B5-525B-AB28-05A6F9ADEE76"><!-- --></a><p>The buffer that is on the screen is called the <strong>front buffer</strong> and the one that is being rendered into is called the <strong>back buffer</strong>. </p>
 </li>
 <li id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-1608F782-3E20-5F42-84DA-24F1F0DB66A8"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-1608F782-3E20-5F42-84DA-24F1F0DB66A8"><!-- --></a><p>Although double-buffering is shown, three or more buffers can be used. </p>
 </li>
 </ul>
 <p><strong>Frame update </strong> </p>
 <p>The following diagram shows the sequence when a client submits a request to be notified when the buffer has been displayed three times. However, the exact details depend on how the composition engine is implemented. If the composition engine knows the screen refresh rate, it can post the composed buffer to the Display Driver and wait for notification that the buffer is on the screen. It could then uses a timer to wait for three frames to be displayed, before it sends the notification. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-F73EEC1A-A2A0-5FF1-B0FC-F391EE67E782"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-F73EEC1A-A2A0-5FF1-B0FC-F391EE67E782"><!-- --></a><span class="figcap">Figure 6. 
             Frame update sequence 
          </span> <img src="GUID-5BCB7325-1755-5A66-99B5-6F5AE003D207_d0e280654_href.png"/></div>
 <p>If the client sends a new request for update while the previous one is still in progress, the previous request is cancelled with the <samp class="codeph">KErrOverflow</samp> error code. This is illustrated in the next diagram. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-11496B17-B655-5CF7-ACD5-9F7F5D80266B"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-11496B17-B655-5CF7-ACD5-9F7F5D80266B"><!-- --></a><span class="figcap">Figure 7. 
             A second request when the first is still in progress 
          </span> <img src="GUID-3F3E8851-3770-5B58-A31E-B5FFCBDE7E55_d0e280666_href.png"/></div>
 <p><strong>Cancelling of all outstanding requests </strong> </p>
 <p>If the client is waiting for a notification when you need to remove the active object that is handling the notification and close the thread, you must call <samp class="codeph">CancelAllUpdateNotifiations()</samp> firstâ€”otherwise the client thread panics. </p>
 <p>However, <samp class="codeph">CancelAllUpdateNotifiations()</samp> only cancels the notifications and not the associated command request. The notifications complete immediate with the <samp class="codeph">KErrCancel</samp> error code. </p>
 <div class="fignone" id="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-216C1A8A-24D9-58FF-9C64-EC0CB3A7A92F"><a name="GUID-8E8FE99A-5F4D-5B0F-87AB-A58EB4BEB6E9__GUID-216C1A8A-24D9-58FF-9C64-EC0CB3A7A92F"><!-- --></a><span class="figcap">Figure 8. 
             Cancel all notifications before closing the connection 
          </span> <img src="GUID-A786DE92-B87E-5D8E-B61D-645BB42BC303_d0e280692_href.png"/></div>
 </div>
 </div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-81A0A2E9-4BB9-58BF-B2D3-08098E7E9C7C.html" title="The Surface Update component provides a communication mechanism between the composition engine and its clients.">Surface Update Component</a></div>
</div>
<div class="relinfo relconcepts"><strong>Related concepts</strong><br/>
<div><a href="GUID-D2ECF215-B53C-5659-BA86-5B658C0C2D2F.html" title="Global surface updates are surface composition update commands that are submitted to all displays rather than to a single one. This causes the Surface Update Server to broadcast the update to all of the registered composition engine instances. Each of these then determines whether the surface is displayed on its associated screen and if so, forces an update.">Global Surface Updates</a></div>
<div><a href="GUID-ADA8CECB-0E70-5B9C-8F36-0714AAF0CD13.html" title="This topic provides an introduction to graphics composition surfaces, which are usually simply called surfaces. Surfaces are pixel buffers that have associated metadata describing the width, height, stride and pixel format and are used as input to the composition components. Surfaces can be multi-buffered and are identified by a 128-bit identifier (called the surface ID).">Graphics Composition Surfaces</a></div>
<div><a href="GUID-55EF3CEB-AF3E-5A32-96F3-F146D1A06C8F.html" title="The Surface Manager is responsible for creating graphics composition surfaces (called surfaces) in system memory and controlling access to them.">Surface Manager Overview</a></div>
<div><a href="GUID-63CB6C7E-44EC-5D0B-A37D-FE78F7D76592.html" title="The Graphics Composition collection is a key part of ScreenPlay. The collection is made up of components that are concerned with composition. This is the process of putting together the output elements from various different sources to create the display that the viewer sees on the screen.">Graphics Composition Collection</a></div>
</div>
</div>   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
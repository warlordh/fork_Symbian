<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Call Stack Information Commands"/>
<meta name="DC.Relation" scheme="URI" content="GUID-26714A57-B6B4-5E81-B512-FB520718482B.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-26714A57-B6B4-5E81-B512-FB520718482B.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-1E43E258-A926-5D24-B0A5-8756491C687F"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Call Stack Information Commands</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2387995 id2388403 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html" title="The device driver framework and how to implement a device driver.">Device Driver Guide</a> &gt; <a href="GUID-26714A57-B6B4-5E81-B512-FB520718482B.html" title="Describes how to get basic information about the system state when problems occur on hardware to help you debug your software.">Debug Monitor Tool</a> &gt; </div>
<h1 class="topictitle1">Call
Stack Information Commands</h1>
<div>
<p>Describes how to use the debug monitor commands to get information about
the call stack. </p>

<ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9D1E42B6-658E-59DF-AC7D-0551B8EF6B61"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9D1E42B6-658E-59DF-AC7D-0551B8EF6B61"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D8F141D7-3BE2-5ADB-8A55-CFFE85E89804">General points</a>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-92B8F3E9-11C1-5260-A862-6CE017984DB0"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-92B8F3E9-11C1-5260-A862-6CE017984DB0"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-1EC3F2E7-6BFF-56BE-B042-DA6940CC909E">Finding the stack</a>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CEFC5F08-C19E-53DD-A0E2-C9C4FFFF3490"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CEFC5F08-C19E-53DD-A0E2-C9C4FFFF3490"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-877742A5-F07F-54B6-B871-255FAAE790EB">Tracing through the call stack heuristically</a>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-8D00F8C3-B367-5C75-89E4-B712002E942D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-8D00F8C3-B367-5C75-89E4-B712002E942D"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7F160B0F-9921-578B-B9B0-7CC4CA3B24C3">Walking through the call stack</a>  </p>
 </li>

</ul>

<div class="section" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D8F141D7-3BE2-5ADB-8A55-CFFE85E89804"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D8F141D7-3BE2-5ADB-8A55-CFFE85E89804"><!-- --></a><h2 class="sectiontitle">General points</h2> <p>Tracing
the call stack is an advanced use of the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-2A0D5950-F1A5-5EE1-87A3-840B1EAD6AAD">m</a> command that allows you to <a href="GUID-DC2CF276-95E2-5810-9B8D-EB8B72E04FEC.html" title="Describes how to use the m command to get a dump of memory.">examine
memory</a>. </p>
 <p>Every time a function is called, the return address
is automatically saved into register <samp class="codeph">R14</samp> (Link Register).
In addition to this the return address is generally pushed onto the call stack;
it is always pushed in debug builds but the push operation is sometimes optimized
out in release builds. This allows you to trace back through the value of <samp class="codeph">R14</samp> and
these saved addresses to see the sequence of function calls. Unfortunately
this is quite tedious to do because the stack is also used for automatic variables
and other data. You need to work out which values on the stack refer to return
addresses. </p>
 <p>When you are debugging only ROM-based code, it is relatively
easy to identify the pushed return addresses because all code addresses will
be in the ROM range: <samp class="codeph">0xF800000</samp> to <samp class="codeph">0xFFEFFFFF</samp> for
the <a href="GUID-D520CBC3-FCAC-5A53-AE1A-E5254ABBC6A2.html#GUID-D520CBC3-FCAC-5A53-AE1A-E5254ABBC6A2__GUID-A5845A0C-2C88-52BB-B7DE-210C2DE481B9">moving
model</a>. However, there is also data in the ROM, which means that an
address on the stack which is in the ROM range could point to data instead
of code. If you want to trace applications loaded into RAM, i.e. anything
not run from drive Z:, then stack tracing is more difficult because the code
can move about and RAM-loaded code is given an address assigned at load time. </p>
 <p>Note
that <a href="GUID-DA62FD4F-2E74-5B2F-B703-4A40DF5F01CA.html" title="MAKSYM is a command line tool that processes the log file generated when building a ROM image, and creates a text file that lists the address of every global and exported function in the ROM">using the MAKSYM
tool</a> is essential for tracing back through the stack. </p>
 </div>

<div class="section" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-1EC3F2E7-6BFF-56BE-B042-DA6940CC909E"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-1EC3F2E7-6BFF-56BE-B042-DA6940CC909E"><!-- --></a><h2 class="sectiontitle">Finding the
stack</h2> <p>To trace back through a thread’s kernel or user stack, you
first need to find the stack pointer value. On the ARM, <samp class="codeph">R13</samp> always
points to the stack, but there are different <samp class="codeph">R13</samp> registers
for each processor mode: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-756C8CDD-AF47-561B-BAA7-EA8FBDEE5245"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-756C8CDD-AF47-561B-BAA7-EA8FBDEE5245"><!-- --></a><p>In thread context: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-81BC92C2-6022-5EBF-BF60-C4D69131C720"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-81BC92C2-6022-5EBF-BF60-C4D69131C720"><!-- --></a><p> <samp class="codeph">R13usr</samp> points
to the thread’s user stack, </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CA6CF8C9-0BA3-5BD4-AECE-80AB3DFCFAD1"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CA6CF8C9-0BA3-5BD4-AECE-80AB3DFCFAD1"><!-- --></a><p> <samp class="codeph">R13svc</samp> points
to the thread’s kernel stack. </p>
 </li>

</ul>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C4A1AD73-64E8-56F7-A7DF-129B2A35FC9D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C4A1AD73-64E8-56F7-A7DF-129B2A35FC9D"><!-- --></a><p>When handling interrupts,
dedicated stacks are used: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7D27A691-1479-578B-9B05-7946C8D84010"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7D27A691-1479-578B-9B05-7946C8D84010"><!-- --></a><p> <samp class="codeph">R13Fiq</samp> points
to the stack used when processing fast interrupts (FIQ). </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CE76BE0F-A6BA-55A6-8CDD-B1E40D97A42D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CE76BE0F-A6BA-55A6-8CDD-B1E40D97A42D"><!-- --></a><p> <samp class="codeph">R13Irq</samp> points
to the stack used when processing general purpose interrupts (IRQ). </p>
 </li>

</ul>
 </li>

</ul>
 <p>To find out which stack to inspect, you need to know what mode the
CPU was in when the fault occurred. The <a href="GUID-7ECDCF7B-3B2A-561F-9136-04BC4DAE46E4.html#GUID-7ECDCF7B-3B2A-561F-9136-04BC4DAE46E4__GUID-BFA2235C-1598-59E6-9F1F-A8281F13A957">processor
mode</a> is identified by the five least-significant bits of the CPSR register.
To get the value of the CPSR register: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-2FAF9E34-CCF0-5C6E-AA6A-9D274433FC49"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-2FAF9E34-CCF0-5C6E-AA6A-9D274433FC49"><!-- --></a><p>use the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-D5F2E0AF-EF03-5150-813B-DF989F12C47B">f</a> command when the debug monitor is triggered by a hardware exception. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-EECA647F-38C8-5B57-80EA-B4D9EBA1928B"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-EECA647F-38C8-5B57-80EA-B4D9EBA1928B"><!-- --></a><p>use the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-0CDF0190-A445-526B-AC1F-D9D58095B18B">r</a> command when the debug monitor is triggered by a panic. </p>
 </li>

</ul>
 <p>The following examples show how to find the stack(s): </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-A5533A14-EEF7-5A9F-B93B-E6E41ECF3928"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-A5533A14-EEF7-5A9F-B93B-E6E41ECF3928"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-4E735CB7-3171-58FB-9D93-EE86702952F6">Kernel &amp; user stacks of the current thread after a hardware exception</a>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-750F8489-5918-5062-9ABC-C8951E50716A"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-750F8489-5918-5062-9ABC-C8951E50716A"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-FB9D2307-01D9-562A-A46F-AAD91D61C32E">Kernel &amp; user stacks of the current thread after a panic</a>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-0ADBB680-827C-5AEF-96F9-B5684B146097"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-0ADBB680-827C-5AEF-96F9-B5684B146097"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C265F9C5-3280-5A4F-B023-56E33D52DDE0">Interrupt stacks</a>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B7CA8584-317C-5ECB-9D4D-2EEFED3F51EA"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B7CA8584-317C-5ECB-9D4D-2EEFED3F51EA"><!-- --></a><p> <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9637574E-A9A0-509D-B9B1-C672E2B13431">Kernel &amp; user stacks of a non-current thread</a>  </p>
 </li>

</ul>
 <p id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-4E735CB7-3171-58FB-9D93-EE86702952F6"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-4E735CB7-3171-58FB-9D93-EE86702952F6"><!-- --></a><strong>Kernel &amp; user stacks
of the current thread after a hardware exception</strong> </p>
 <p>Use the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-D5F2E0AF-EF03-5150-813B-DF989F12C47B">f</a> command. </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-A92D63C6-1594-5C95-AAC2-42D2FDE5160F"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-A92D63C6-1594-5C95-AAC2-42D2FDE5160F"><!-- --></a>Fault Category: Exception  Fault Reason: 10000000
ExcId 00000001 CodeAddr f816c908 DataAddr 80000001 Extra c0007003
Exc 1 Cpsr=60000010 FAR=80000001 FSR=c0007003
 R0=00000000  R1=00000000  R2=30000000  R3=80000001
 R4=00000001  R5=00403d88  R6=00002000  R7=f816c768
 R8=00000012  R9=00000040 R10=00000000 R11=00403fa4
R12=00403d5c R13=00403d70 R14=f80906f8 R15=f816c908
R13Svc=6571e000 R14Svc=f80074bc SpsrSvc=80000010
</pre>
 <p>In this example: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7C35AE63-13E9-5D8D-A77F-CD1A0B9A5EF4"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7C35AE63-13E9-5D8D-A77F-CD1A0B9A5EF4"><!-- --></a><p>the kernel stack is
the value of <samp class="codeph">R13Svc</samp>, i.e. <samp class="codeph">0x6571e00</samp>. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D70628B9-A750-5557-BACF-471D2D75A2E4"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D70628B9-A750-5557-BACF-471D2D75A2E4"><!-- --></a><p>the user stack is the
value of <samp class="codeph">R13</samp>, i.e. <samp class="codeph">0x00403d70</samp>. </p>
 </li>

</ul>
 <p id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-FB9D2307-01D9-562A-A46F-AAD91D61C32E"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-FB9D2307-01D9-562A-A46F-AAD91D61C32E"><!-- --></a><strong>Kernel &amp; user stacks
of the current thread after a panic</strong> </p>
 <p>Use the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-0CDF0190-A445-526B-AC1F-D9D58095B18B">r</a> command. </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-705AF9EC-4513-5C3C-BD28-A91992D73296"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-705AF9EC-4513-5C3C-BD28-A91992D73296"><!-- --></a>MODE_USR:
 R0=6571de54  R1=0000002a  R2=00000002  R3=ffffffff
 R4=0000002a  R5=f8170414  R6=6571df14  R7=6403cc50
 R8=00000001  R9=6403c44c R10=640002f8 R11=6571de70
R12=00000020 R13=00404e00 R14=f80818c0 R15=f800bfa8
CPSR=60000013
MODE_FIQ:
 R8=00000000  R9=ffffffff R10=ffffffff R11=00000000
R12=00000000 R13=64000d0c R14=c080079c SPSR=e00000dc
MODE_IRQ:
R13=6400110c R14=00000013 SPSR=20000013
MODE_SVC:
R13=6571de54 R14=f80328bc SPSR=60000010
MODE_ABT:
R13=6400090c R14=ccbfd0e0 SPSR=b00000d9
MODE_UND:
R13=6400090c R14=b5a39950 SPSR=f000009d
</pre>
 <p>In this example: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C23A3F68-FAEB-596A-AF51-810E7429D17B"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C23A3F68-FAEB-596A-AF51-810E7429D17B"><!-- --></a><p>the kernel stack is
the value of <samp class="codeph">R13</samp> under <samp class="codeph">MODE_SVC:</samp>, i.e. <samp class="codeph">0x6571de54</samp>. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-98FD71CA-BD17-5CB3-B0A8-0FBECFBF3ECF"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-98FD71CA-BD17-5CB3-B0A8-0FBECFBF3ECF"><!-- --></a><p>the user stack is the
value of <samp class="codeph">R13</samp> under <samp class="codeph">MODE_USR:</samp>, i.e. <samp class="codeph">0x00404e00</samp>. </p>
 </li>

</ul>
 <p id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C265F9C5-3280-5A4F-B023-56E33D52DDE0"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C265F9C5-3280-5A4F-B023-56E33D52DDE0"><!-- --></a><strong>Interrupt stacks</strong> </p>
 <p>Use
the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-0CDF0190-A445-526B-AC1F-D9D58095B18B">r</a> command. </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-28065EA2-194E-5D8D-8C1B-D85299B91431"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-28065EA2-194E-5D8D-8C1B-D85299B91431"><!-- --></a>MODE_USR:
 R0=6571de54  R1=0000002a  R2=00000002  R3=ffffffff
 R4=0000002a  R5=f8170414  R6=6571df14  R7=6403cc50
 R8=00000001  R9=6403c44c R10=640002f8 R11=6571de70
R12=00000020 R13=00404e00 R14=f80818c0 R15=f800bfa8
CPSR=60000013
MODE_FIQ:
 R8=00000000  R9=ffffffff R10=ffffffff R11=00000000
R12=00000000 R13=64000d0c R14=c080079c SPSR=e00000dc
MODE_IRQ:
R13=6400110c R14=00000013 SPSR=20000013
MODE_SVC:
R13=6571de54 R14=f80328bc SPSR=60000010
MODE_ABT:
R13=6400090c R14=ccbfd0e0 SPSR=b00000d9
MODE_UND:
R13=6400090c R14=b5a39950 SPSR=f000009d
</pre>
 <p>In this example: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-6A48007B-973A-50F1-BCF5-31A72EC68D57"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-6A48007B-973A-50F1-BCF5-31A72EC68D57"><!-- --></a><p>the IRQ stack is the
value of <samp class="codeph">R13</samp> under <samp class="codeph">MODE_IRQ:</samp>, i.e. <samp class="codeph">0x6400110c</samp>. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-65CD3376-7D50-548F-A473-04B049034D0D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-65CD3376-7D50-548F-A473-04B049034D0D"><!-- --></a><p>the FRQ stack is the
value of <samp class="codeph">R13</samp> under <samp class="codeph">MODE_FIQ:</samp>, i.e. <samp class="codeph">0x64000d0c</samp>. </p>
 </li>

</ul>
 <p id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9637574E-A9A0-509D-B9B1-C672E2B13431"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9637574E-A9A0-509D-B9B1-C672E2B13431"><!-- --></a><strong>Kernel &amp; user stacks
of a non-current thread</strong> </p>
 <p>Use the output of the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-D0175D78-6F84-5F4F-BA90-2C591B473C69">i</a>, <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-1DED2B2F-E780-50A0-8325-5DA22BC7D3E0">q</a> and <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-FB2E24A6-9744-5169-BA90-DDF84DF1D3E5">c0</a> commands. </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-F45908AC-ADF8-5B92-AA8C-4C33D77D24B8"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-F45908AC-ADF8-5B92-AA8C-4C33D77D24B8"><!-- --></a>THREAD at 6403c194 VPTR=f8046c18 AccessCount=5 Owner=6403bb4c
Full name t_dmasim::Main
Thread MState READY
Default priority 12 WaitLink Priority 12
ExitInfo 3,0,
Flags 00000002, Handles 6403b418
Supervisor stack base 6571d000 size 1000
User stack base 00403000 size 2000
Id=25, Alctr=00700000, Created alctr=00700000, Frame=00000000
Trap handler=00000000, ActiveScheduler=007000c8, Exception handler=00000000
TempObj=00000000 TempAlloc=00000000
NThread @ 6403c44c Pri 12 NState READY
Next=6403c44c Prev=6403c44c Att=03 iUserContextType=02
HeldFM=00000000 WaitFM=00000000 AddrSp=6403bb4c
Time=0 Timeslice=20 ReqCount=0
SuspendCount=0 CsCount=1 CsFunction=00000000
SavedSP=6571df98
DACR f800bd2c
R13_USR 0d404c38 R14_USR 00000001 SPSR_SVC 00000000
 R4 f8022d84  R5 6571dfd4  R6 6571dfbc  R7 f8022db8
 R8 f800bddc  R9 f800a454 R10 00000000 R11 f801daac
 PC 60000010
</pre>
 <p>In this example: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-A4217DD4-A46C-5EAE-85D3-2EEAD763B726"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-A4217DD4-A46C-5EAE-85D3-2EEAD763B726"><!-- --></a><p>the kernel stack is
the value of <samp class="codeph">SavedSP</samp>, i.e. <samp class="codeph">0x6571df98</samp>. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-8220888D-7411-5AC5-AD20-89E892301188"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-8220888D-7411-5AC5-AD20-89E892301188"><!-- --></a><p>the user stack is the
value of <samp class="codeph">R13_USR</samp>, i.e. <samp class="codeph">0x0d404c38</samp>. </p>
 </li>

</ul>
 </div>

<div class="section" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-877742A5-F07F-54B6-B871-255FAAE790EB"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-877742A5-F07F-54B6-B871-255FAAE790EB"><!-- --></a><h2 class="sectiontitle">Tracing through
the stack heuristically</h2> <p>One way of tracing through the call stack
is to assume that every word on the stack which looks like a ROM code address
is a saved return address. We say that this heuristic because: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B5BF6BD6-0163-55F9-A34D-EB78982848B0"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B5BF6BD6-0163-55F9-A34D-EB78982848B0"><!-- --></a><p>some data words may
look like code addresses in ROM. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-0A978212-73B6-5C89-B805-84327B9CF733"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-0A978212-73B6-5C89-B805-84327B9CF733"><!-- --></a><p>there may be saved return
addresses left over from previous function calls. For example, suppose that <samp class="codeph">F()</samp> calls <samp class="codeph">A()</samp> and
then <samp class="codeph">B()</samp> in sequence. <samp class="codeph">A()</samp> itself calls <samp class="codeph">X()</samp>,
which calls <samp class="codeph">Y()</samp>. If a crash occurs in <samp class="codeph">B()</samp>,
the saved return addresses from the calls to <samp class="codeph">X()</samp> and <samp class="codeph">Y()</samp> are
still present on the stack and may be mistaken for function calls occuring
while <samp class="codeph">B()</samp> is active. </p>
 <p>This scenario happens frequently
when <samp class="codeph">B()</samp> allocates a buffer (e.g. <a href="GUID-0B9C8884-6BFF-35E2-AA6F-E4057B85AFCF.html"><span class="apiname">TBuf</span></a>)
on the stack which overlaps old stack frames. </p>
 <div class="fignone" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-FED8CC0F-F1A0-59C9-B082-2D3B499D00D5"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-FED8CC0F-F1A0-59C9-B082-2D3B499D00D5"><!-- --></a>
<img src="GUID-A328F9E3-7D91-594A-A589-E8CE5FA9227A_d0e299982_href.png"/>
</div>
 </li>

</ul>
 <p>If you want to trace applications loaded into RAM, then stack tracing
is more difficult because RAM-loaded DLLs are given addresses assigned at
load time. </p>
 <p>On ARM, the stack pointer starts at the higher address
end and moves 'down' towards the lower address end. This means that values
at the top of the memory dump are more recent. You need to look back through
this for code addresses. For ROM code this will be words with most significant
byte in the range <samp class="codeph">0xF8</samp> to <samp class="codeph">0xFF</samp>, remembering
that they are little-endian. This can either be done manually, or automatically
using the <span class="filepath">printsym.pl</span> perl script, which can be found
in <samp class="codeph">...\epoc32\tools</samp>. </p>
 <p>Let's follow this in an example
session: </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D761405E-86BD-55ED-ACC6-C6D2125FDCE7"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-D761405E-86BD-55ED-ACC6-C6D2125FDCE7"><!-- --></a><p>Decide whether the crash
has been caused by a panic or an exception using the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-D5F2E0AF-EF03-5150-813B-DF989F12C47B">f</a> command: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-480D9B52-C556-5733-91E2-87D7F12651FC"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-480D9B52-C556-5733-91E2-87D7F12651FC"><!-- --></a>.f
Fault Category: EXAMPLE  Fault Reason: 0000002a
ExcId 00000000 CodeAddr 00000000 DataAddr 00000000 Extra 00000000
</pre>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-73690262-2895-51ED-9532-E76638B0EC1E"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-73690262-2895-51ED-9532-E76638B0EC1E"><!-- --></a><p>This shows that the
crash was caused by a panic, so now use the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-0CDF0190-A445-526B-AC1F-D9D58095B18B">r</a> command to find the CPU mode and the stack pointer: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-1FB9E3E1-54FF-5109-804D-2D6109626A66"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-1FB9E3E1-54FF-5109-804D-2D6109626A66"><!-- --></a>.r
MODE_USR:
 R0=6571de54  R1=0000002a  R2=00000002  R3=ffffffff
 R4=0000002a  R5=f8170414  R6=6571df14  R7=6403cba8
 R8=00000001  R9=6403c41c R10=640002f8 R11=6571de70
R12=00000020 R13=00404e00 R14=f80818c0 R15=f800bfa8
CPSR=60000013
MODE_FIQ:
 R8=00000000  R9=ffffffff R10=ffffffff R11=00000000
R12=00000000 R13=64000d0c R14=c080079c SPSR=e00000dc
MODE_IRQ:
R13=6400110c R14=00000013 SPSR=20000013
MODE_SVC:
R13=6571de54 R14=f80328bc SPSR=60000010
MODE_ABT:
R13=6400090c R14=ffff0010 SPSR=400000d7
MODE_UND:
R13=6400090c R14=95221110 SPSR=f000009d
</pre>
 <p>The panic happened in supervisor mode, because <samp class="codeph">CPSR
&amp;                 0x1F == 0x13</samp>, so <samp class="codeph">R13Svc</samp>, i.e.
the value of <samp class="codeph">R13</samp> shown under <samp class="codeph">MODE_SVC:</samp> in
the above display, is the stack pointer to look at; this has the value <samp class="codeph">0x6571DE54</samp>. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CE74A8F7-97EF-5ACD-BA16-A35CDA293B3D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-CE74A8F7-97EF-5ACD-BA16-A35CDA293B3D"><!-- --></a><p>Using the <a href="GUID-08E14B34-5144-5AA8-AA55-7AF03671676C.html#GUID-08E14B34-5144-5AA8-AA55-7AF03671676C__GUID-2A0D5950-F1A5-5EE1-87A3-840B1EAD6AAD">m</a> command to look at memory starting at location <samp class="codeph">0x6571DE54</samp> gives: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-BF6D6BD9-ADDE-587F-85B6-39140620B9AC"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-BF6D6BD9-ADDE-587F-85B6-39140620B9AC"><!-- --></a>.m6571de54+200
6571de54: 07 00 00 10 14 04 17 f8 00 00 00 00 d4 4e 40 00 .............N@.
6571de64: e8 de 71 65 74 de 71 65 74 fb 16 f8 88 28 03 f8 ..qet.qet....(..
6571de74: 0c d4 03 f8 64 35 03 f8 00 00 00 00 00 00 00 00 ....d5..........
6571de84: d0 00 00 00 14 df 71 65 a8 cb 03 64 a8 cb 03 64 ......qe...d...d
6571de94: d0 00 00 00 14 df 71 65 1c df 71 65 ec 4e 40 00 ......qe..qe.N@.
6571dea4: 1c c4 03 64 b4 2a 03 f8 00 00 00 00 14 df 71 65 ...d.*........qe
6571deb4: d0 de 71 65 c4 de 71 65 b0 ab 03 f8 00 00 00 00 ..qe..qe........
6571dec4: e0 ba 03 64 14 df 71 65 1c df 71 65 01 00 00 00 ...d..qe..qe....
6571ded4: 1c c4 03 64 f8 02 00 64 10 df 71 65 ec de 71 65 ...d...d..qe..qe
6571dee4: 84 da 01 f8 5c fb 16 f8 00 4e 40 00 00 00 00 00 ....\....N@.....
6571def4: 00 4e 40 00 00 00 00 00 d3 00 00 00 ec 4e 40 00 .N@..........N@.
6571df04: d4 df 71 65 14 df 71 65 e0 db 01 f8 c0 d9 01 f8 ..qe..qe........
6571df14: a8 cb 03 64 e0 ba 03 64 01 00 01 00 00 00 00 00 ...d...d........
6571df24: 00 00 00 00 d4 4e 40 00 00 00 00 30 40 00 00 00 .....N@....0@...
6571df34: 13 00 00 60 98 df 71 65 48 df 71 65 f4 81 00 f8 ...`..qeH.qe....
6571df44: 8c 7a 00 f8 68 df 71 65 58 df 71 65 6c df 71 65 .z..h.qeX.qel.qe
6571df54: 60 df 71 65 0c 2b 00 f8 bc 2a 00 f8 84 df 71 65 `.qe.+...*....qe
6571df64: 70 df 71 65 e4 7d 04 f8 08 2b 00 f8 0d 00 00 00 p.qe.}...+......
6571df74: 0a 00 00 30 40 00 00 00 54 65 73 74 44 6d 61 53 ...0@...TestDmaS
6571df84: 69 6d 04 f8 a9 4b 40 00 b8 df 71 65 9c df 71 65 im...K@...qe..qe
6571df94: 2c be 00 f8 2c bd 00 f8 38 4c 40 0d 01 00 00 00 ,...,...8L@.....
6571dfa4: 00 00 00 00 84 2d 02 f8 d4 df 71 65 bc df 71 65 .....-....qe..qe
6571dfb4: b8 2d 02 f8 dc bd 00 f8 54 a4 00 f8 00 00 00 00 .-......T.......
6571dfc4: ac da 01 f8 10 00 00 60 d8 df 71 65 70 74 00 f8 .......`..qept..
6571dfd4: b8 da 01 f8 d4 4e 40 00 20 f7 16 f8 d0 4e 40 00 .....N@. ....N@.
6571dfe4: 00 00 00 00 00 00 00 00 ec 4e 40 00 40 00 00 00 .........N@.@...
</pre>
 <p>We can look for potential ROM addresses by scanning the log
and look up the corresponding function name in the symbol file generated <a href="GUID-DA62FD4F-2E74-5B2F-B703-4A40DF5F01CA.html" title="MAKSYM is a command line tool that processes the log file generated when building a ROM image, and creates a text file that lists the address of every global and exported function in the ROM">using the MAKSYM tool</a> .
The first one is <samp class="codeph">0xF8170414</samp> at offset <samp class="codeph">4</samp> in
the memory dump. </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-3197B03A-FD94-5D78-B699-22BDCE71DD1D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-3197B03A-FD94-5D78-B699-22BDCE71DD1D"><!-- --></a><p>Alternatively, we can
use the <span class="filepath">printsym.pl</span> perl script, passing it the dump
output. The following is part of the output: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B4289E03-6E98-591D-9E26-CEEDC3CD9437"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B4289E03-6E98-591D-9E26-CEEDC3CD9437"><!-- --></a>R:\base\e32\rombuild&gt;perl -S printsym.pl ASSABETARM4D.symbol
ROM Symbols from ASSABETARM4D.symbol
Please enter data to be decoded
6571de54: 07 00 00 10 14 04 17 f8 00 00 00 00 d4 4e 40 00 .............N@.
= 10000007 ....    
= f8170414 ....  etext=. + 0x0
= 00000000 ....
= 00404ed4 .N@.
6571de64: e8 de 71 65 74 de 71 65 74 fb 16 f8 88 28 03 f8 ..qet.qet....(..
= 6571dee8 ..qe
= 6571de74 t.qe
= f816fb74 t...  DDmaTestChannel::DoCreate(int, TDesC8 const *, TVersion const &amp;
) + 0x24
= f8032888 .(..  Kern::Fault(char const *, int) + 0xc
6571de74: 0c d4 03 f8 64 35 03 f8 00 00 00 00 00 00 00 00 ....d5..........
= f803d40c ....  RHeap::Alloc(int) + 0xf4
= f8033564 d5..  Kern::MutexSignal(DMutex &amp;) + 0xc
= 00000000 ....
= 00000000 ....

[............ truncated ...............]

= f801da84 ....  DLogicalDevice::ChannelCreate(DLogicalChannelBase *&amp;, TChannelC
reateInfo &amp;) + 0xd0
= f816fb5c \...  DDmaTestChannel::DoCreate(int, TDesC8 const *, TVersion const &amp;
) + 0xc
= 00404e00 .N@.
= 00000000 ....
6571def4: 00 4e 40 00 00 00 00 00 d3 00 00 00 ec 4e 40 00 .N@..........N@.
= 00404e00 .N@.
= 00000000 ....
= 000000d3 ....
= 00404eec .N@.
6571df04: d4 df 71 65 14 df 71 65 e0 db 01 f8 c0 d9 01 f8 ..qe..qe........
= 6571dfd4 ..qe
= 6571df14 ..qe
= f801dbe0 ....  ExecHandler::ChannelCreate(TDesC8 const &amp;, TChannelCreateInfo &amp;
, int) + 0x134
= f801d9c0 ....  DLogicalDevice::ChannelCreate(DLogicalChannelBase *&amp;, TChannelC
reateInfo &amp;) + 0xc

[.......................... truncated .........................]

= f8022db8 .-..  ExecHandler::DebugPrint(void *, int) + 0x34
= f800bddc ....  A::UserDebugPrint(unsigned char const *, int, int) + 0xc
= f800a454 T...  EpocSlowExecTable + 0xc
= 00000000 ....
6571dfc4: ac da 01 f8 10 00 00 60 d8 df 71 65 70 74 00 f8 .......`..qept..
= f801daac ....  ExecHandler::ChannelCreate(TDesC8 const &amp;, TChannelCreateInfo &amp;
, int) + 0x0
= 60000010 ...`
= 6571dfd8 ..qe
= f8007470 pt..  __ArmVectorSwi + 0xd8
6571dfd4: b8 da 01 f8 d4 4e 40 00 20 f7 16 f8 d0 4e 40 00 .....N@. ....N@.
= f801dab8 ....  ExecHandler::ChannelCreate(TDesC8 const &amp;, TChannelCreateInfo &amp;
, int) + 0xc
= 00404ed4 .N@.
= f816f720  ...  etext=. + 0x560
= 00404ed0 .N@.
6571dfe4: 00 00 00 00 00 00 00 00 ec 4e 40 00 40 00 00 00 .........N@.@...
= 00000000 ....
= 00000000 ....
= 00404eec .N@.
= 00000040 @...
^C
R:\base\e32\rombuild&gt;
</pre>
 <p>There are several false positives in this output (and even
more in the truncated parts). So some study of the source code is needed to
discard the noise and find the actual call stack. Here it is (innermost frame
first): </p>
 <ul>
<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C83CA525-1731-56BC-8C98-4AEEB5809780"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-C83CA525-1731-56BC-8C98-4AEEB5809780"><!-- --></a><p> <samp class="codeph">Kern::Fault</samp>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-40B7B48A-F6A0-5CD6-9C0C-2E432FF760BA"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-40B7B48A-F6A0-5CD6-9C0C-2E432FF760BA"><!-- --></a><p> <samp class="codeph">DDmaTestChannel::DoCreate</samp>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-E9327B91-F69C-5BC1-B964-FE1B90CA314C"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-E9327B91-F69C-5BC1-B964-FE1B90CA314C"><!-- --></a><p> <samp class="codeph">ExecHandler::ChannelCreate</samp>  </p>
 </li>

<li id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-0391ADD8-EF56-51F9-987F-B9111903EAC7"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-0391ADD8-EF56-51F9-987F-B9111903EAC7"><!-- --></a><p> <samp class="codeph"> __ArmVectorSwi</samp>  </p>
 </li>

</ul>
 <p>Note that for the sake of the example, a call to <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-45337A03-5893-3D0D-948C-23BDCF8AECBD"><span class="apiname">Kern::Fault()</span></a> was
deliberately inserted into <a href="GUID-63F99C5E-55C4-305B-BA86-CF73B0CF1520.html#GUID-63F99C5E-55C4-305B-BA86-CF73B0CF1520__GUID-F0A1E76C-A0E1-39C9-845C-BE19FE2EB415"><span class="apiname">DDmaTestChannel::DoCreate()</span></a>. </p>
 <p>All
other function names are false positives and should be ignored. </p>
 </li>

</ul>
 </div>

<div class="section" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7F160B0F-9921-578B-B9B0-7CC4CA3B24C3"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-7F160B0F-9921-578B-B9B0-7CC4CA3B24C3"><!-- --></a><h2 class="sectiontitle">Walking through
the call stack</h2> <p>The heuristic method is quick but produces lots
of false positives. Another option is to manually reconstitute the call stack
from the memory dump. This is relatively easy for debug builds because GCC
uses R11 as a frame pointer (FP) and generates the same prologue/epilogue
for every function. </p>
 <p>For release builds, there is no generic solution.
It is necessary to check the generated assembler code as there is no standard
prologue/epilogue and R11 is not used as frame pointer. </p>
 <p>A typical
prologue for a debug ARM function looks like this: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9C1F71E0-5F2A-50FF-ABD2-035EB9B5B4D9"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-9C1F71E0-5F2A-50FF-ABD2-035EB9B5B4D9"><!-- --></a>mov        ip, sp
stmfd    sp!, {fp, ip, lr, pc}
sub        fp, ip, #4        /* FP now points to base of stack frame */
sub        sp, sp, #16    /* space for local variables */
</pre>
 <p>noting that: <samp class="codeph">SP = R13</samp>, <samp class="codeph">FP = R11</samp>, <samp class="codeph">IP
=           R12</samp>, <samp class="codeph">LR = R14</samp>, and <samp class="codeph">PC = R15</samp>. </p>
 <p>This
code creates the following stack frame: </p>
 <div class="fignone" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-5CE044A2-CDD0-5A09-B824-BAF46324AB27"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-5CE044A2-CDD0-5A09-B824-BAF46324AB27"><!-- --></a>
<img src="GUID-F12437C5-BD96-5B43-AD76-614CFAB104D2_d0e300180_href.png"/>
</div>
 <p>Looking at the example session listed in when <a href="GUID-1E43E258-A926-5D24-B0A5-8756491C687F.html#GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-877742A5-F07F-54B6-B871-255FAAE790EB">tracing through the stack heuristically</a>. in which the crash is due
to a panic, the FP value is the R11 value; this is <samp class="codeph">0x6571de70</samp>.
This gives us the innermost stack frame: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-DE5FFB23-A85D-562F-858B-CFF407448E36"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-DE5FFB23-A85D-562F-858B-CFF407448E36"><!-- --></a>6571de64:    e8 de 71 65 &lt;------------- pointer to previous stack frame 
            74 de 71 65 
            74 fb 16 f8 &lt;------------- Saved return address 
            88 28 03 f8 &lt;------------- FP points to this word
</pre>
 <p>Looking up the saved return address, <samp class="codeph">0xf816fb74</samp>,
in the symbol file shows that the current function was called from <samp class="codeph">DDmaChannel::DoCreate()</samp>. </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-576615AE-2253-595C-97F5-1DC05F79B750"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-576615AE-2253-595C-97F5-1DC05F79B750"><!-- --></a>f816fb50    0198    DDmaTestChannel::DoCreate(int, TDesC8 const *, TVersion const &amp;)
f816fce8    007c    DDmaTestChannel::~DDmaTestChannel(void)
f816fd64    0294    DDmaTestChannel::Request(int, void *, void *)
</pre>
 <p>Using the pointer to the previous stack frame saved into the
current frame, we can decode the next frame: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-570DB2F6-A76F-5858-816F-7A0E8562B35A"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-570DB2F6-A76F-5858-816F-7A0E8562B35A"><!-- --></a>6571ded4:    1c c4 03 64 
            f8 02 00 64 
            10 df 71 65 &lt;------------- pointer to previous stack frame 
            ec de 71 65 

6571dee4:    84 da 01 f8 &lt;------------- saved return address 
            5c fb 16 f8 &lt;------------- start of second stack frame 
            00 4e 40 00 
            00 00 00 00 
</pre>
 <p>Looking up the saved return address, <samp class="codeph">0xf801da84</samp>,
in the symbol file shows that <samp class="codeph">DDmaTestChannel::DoCreate()</samp> was
called from <samp class="codeph">DLogicalDevice::ChannelCreate()</samp>. </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B36A9D49-5414-5CC3-8CBF-A2A0EE332B3C"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B36A9D49-5414-5CC3-8CBF-A2A0EE332B3C"><!-- --></a>f801d9b4    00f8    DLogicalDevice::ChannelCreate(DLogicalChannelBase *&amp;, TChannelCreateInfo &amp;)
f801daac    01b8    ExecHandler::ChannelCreate(TDesC8 const &amp;, TChannelCreateInfo &amp;, int)
f801dc64    00e4    ExecHandler::ChannelRequest(DLogicalChannelBase *, int, void *, void *)
</pre>
 <p>And here is the third stack frame: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B07DEA17-BA2F-5FEA-8781-E44682BE2D1D"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-B07DEA17-BA2F-5FEA-8781-E44682BE2D1D"><!-- --></a>6571df04:    d4 df 71 65 &lt;------------- pointer to previous stack frame 
            14 df 71 65 
            e0 db 01 f8 &lt;------------- saved return address 
            c0 d9 01 f8 &lt;------------- start of third stack frame 
</pre>
 <p>So <samp class="codeph">DLogicalDevice::ChannelCreate()</samp> was called
from <samp class="codeph">ExecHandler::ChannelCreate()</samp>. </p>
 <p>Note that this
mechanical way of walking the stack is valid only for debug functions. For
release functions, it is necessary to study the code generated by the compiler. </p>
 <p>For
completness, this is a typical prologue for a debug THUMB function: </p>
 <pre class="codeblock" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-2DC6601E-6304-5638-A1F6-F44F1AB26288"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-2DC6601E-6304-5638-A1F6-F44F1AB26288"><!-- --></a>push    { r7, lr }
sub        sp, #28
add        r7, sp, #12 /* R7 is THUMB frame pointer */
</pre>
 <p>and this creates the following stack frame: </p>
 <div class="fignone" id="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-85FAEE94-6D61-5D6B-84CB-6A9491927077"><a name="GUID-1E43E258-A926-5D24-B0A5-8756491C687F__GUID-85FAEE94-6D61-5D6B-84CB-6A9491927077"><!-- --></a>
<img src="GUID-5CF162CA-4395-58AC-A318-2BF178276A57_d0e300257_href.png"/>
</div>
 <p>A call stack can mix ARM and THUMB frames. Odd return addresses
are used for THUMB code and even ones for ARM code. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-26714A57-B6B4-5E81-B512-FB520718482B.html" title="Describes how to get basic information about the system state when problems occur on hardware to help you debug your software.">Debug Monitor Tool</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
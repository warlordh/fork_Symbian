<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Shared Chunks"/>
<meta name="abstract" content="A shared chunk is a mechanism that kernel-side code uses to share memory buffers safely with user-side code."/>
<meta name="description" content="A shared chunk is a mechanism that kernel-side code uses to share memory buffers safely with user-side code."/>
<meta name="DC.Relation" scheme="URI" content="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Shared Chunks</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2387995 id2388473 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html" title="The device driver framework and how to implement a device driver.">Device Driver Guide</a> &gt; <a href="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html" title="This section describes how device drivers can use the services that the Kernel provides.">Kernel-Side Services</a> &gt; </div>
<h1 class="topictitle1">Shared
Chunks</h1>
<div><p>A shared chunk is a mechanism that kernel-side code uses to share
memory buffers safely with user-side code. </p>

<p>A shared chunk is a mechanism that kernel-side code can use to share memory
buffers safely with user-side code. This topic describes this concept, and
explains how to use the shared chunk APIs. </p>

<ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-2D439828-C4DB-5D0F-83EF-46EDD9D2C2CF"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-2D439828-C4DB-5D0F-83EF-46EDD9D2C2CF"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F09BAE7B-805F-5CF1-8C9A-AD23C50026AD">What are shared chunks?</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-EE669369-2315-5EB3-A4EF-CF1778DF4432"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-EE669369-2315-5EB3-A4EF-CF1778DF4432"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FBFA1B23-C6CA-5E9A-A461-E4822EB9E76F">Creating a shared chunk</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-0BE8F408-05E8-5F1A-987A-E35CD8D92703"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-0BE8F408-05E8-5F1A-987A-E35CD8D92703"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D55514EA-D218-52F2-807B-78D58E99D810">Opening a handle to the shared chunk for user-side access</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-5A0B2A6A-169F-5158-B554-A346C34C16D7"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-5A0B2A6A-169F-5158-B554-A346C34C16D7"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F63A506B-1573-5F6A-B0C7-CEE5BF1FAD72">Discarding a handle</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9ED0C21B-5B51-5E38-B77F-96E879E9A053"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9ED0C21B-5B51-5E38-B77F-96E879E9A053"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-86446948-6012-59B9-8411-BF0E98DC7D3A">Closing and destroying a shared chunk</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9E297A46-9C63-59C2-A515-1AB8F3BD09BA"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9E297A46-9C63-59C2-A515-1AB8F3BD09BA"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6D3AAC95-E52B-5E78-B57E-0433ECF14C3A">Committing memory</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-BF5A0349-1DD7-5266-9F86-1DC3F73CC2CC"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-BF5A0349-1DD7-5266-9F86-1DC3F73CC2CC"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E9630D2D-794B-5AB1-8980-0927E040C0C5">Passing data from user-side code to another device driver</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-EA0A1F4A-DB1D-55F8-8EB1-C3E139AA9B47"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-EA0A1F4A-DB1D-55F8-8EB1-C3E139AA9B47"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-4C374CF0-0680-5A27-94E7-BB0FD75413AF">Passing data between user-side code</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A0448628-461A-52F9-A2D4-DE3863005966"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A0448628-461A-52F9-A2D4-DE3863005966"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A8FF0519-9FDC-53D5-8BD6-A3AEA6BFDD46">Direct peripheral access to shared chunks</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-C6A46B05-12C8-5459-ABD7-0BD173E36580"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-C6A46B05-12C8-5459-ABD7-0BD173E36580"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D8E298EA-A4CD-5501-B5F1-B8F0EE93CE84"> Example code</a>  </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B17ECEF5-920C-516C-80D1-15AFD3FAA282"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B17ECEF5-920C-516C-80D1-15AFD3FAA282"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D284D6D0-400D-53D2-9A43-05CEE28DFDC4">Example: Creating a shared chunk</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-75FB5604-6468-502B-A005-38D81DE03588"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-75FB5604-6468-502B-A005-38D81DE03588"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6501F90A-5330-5BC9-A991-A3BECCCA6CDD">Example: Opening a handle to the shared chunk for user-side access</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FF092178-84C4-5996-85C2-6B9E111EFFD6"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FF092178-84C4-5996-85C2-6B9E111EFFD6"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-062C405B-B10F-54A8-8F61-418CAE6019D8">Example: Using a DFC to notify destruction of chunk</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-02D42EFC-B20B-5E34-B555-657DC5DFB748"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-02D42EFC-B20B-5E34-B555-657DC5DFB748"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-97BF15A2-E74A-51DE-B003-16E1DFF8964E">Example: Committing memory</a>  </p>
 </li>

</ul>
 </li>

</ul>

<p>You may find it useful to refer to the general sections : <a href="GUID-8D80AA51-5108-5D4B-B6B9-7FA47570AB89.html">Device
Driver Concepts</a> and <a href="GUID-4A402DAD-99D3-595E-87FD-AAB5A970D6CC.html">Device
Driver Framework</a>. </p>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F09BAE7B-805F-5CF1-8C9A-AD23C50026AD"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F09BAE7B-805F-5CF1-8C9A-AD23C50026AD"><!-- --></a><h2 class="sectiontitle">What are shared
chunks?</h2> <p>A shared chunk is a mechanism that kernel-side code uses
to share memory buffers safely with user-side code. References to kernel-side
code always mean device driver code. </p>
 <p>The main points to note about
shared chunks are: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9B4BC2DE-59AD-50F9-AF37-4966D741741A"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9B4BC2DE-59AD-50F9-AF37-4966D741741A"><!-- --></a><p>They can be created
and destroyed only by device drivers. It is typical behaviour for user-side
code, which in this context we refer to as the <em>client</em> of the device
driver, to pass a request to the device driver for a handle to a shared chunk.
This causes the device driver to open a handle to the chunk and return the
handle <em>value</em> to the client. Successful handle creation also causes
the chunk's memory to be mapped into the address space of the process to which
the client's thread belongs. Note, however, that the driver dictates <em>when</em> the
chunk needs to be created, and <em>when</em> memory needs to be committed. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B5D39B0E-150A-56E8-A396-EDDC36D3061B"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B5D39B0E-150A-56E8-A396-EDDC36D3061B"><!-- --></a><p>Like all kernel-side
objects, a shared chunk is reference counted. This means that it remains in
existence for as long as the reference count is greater than zero. Once all
opened references to the shared chunk have been <em>closed</em>, regardless
of whether the references are user-side or kernel-side, it is destroyed. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-348564CB-647F-5658-9DDC-5E0B022B7644"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-348564CB-647F-5658-9DDC-5E0B022B7644"><!-- --></a><p>User-side code that
has gained access to a shared chunk from one device driver can pass this to
a second device driver. The second device driver must <em>open</em> the chunk
before it can be used. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8496E32C-48C7-5778-B886-0F63C6EF7ED6"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8496E32C-48C7-5778-B886-0F63C6EF7ED6"><!-- --></a><p>More than one user-side
application can access the data in a shared chunk. A handle to a shared chunk
can be passed from one process to another using standard handle passing mechanisms.
In practice, handles are almost always passed in a client-server context via
inter process communication (IPC). </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8F0AAFD5-661A-5569-AABF-C88287DF836B"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8F0AAFD5-661A-5569-AABF-C88287DF836B"><!-- --></a><p>Processes that share
the data inside a chunk should communicate the location of that data as an
offset from the start of the chunk, and <em>not</em> as an absolute address.
The shared chunk may appear at different addresses in the address spaces of
different user processes. </p>
 </li>

</ul>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FBFA1B23-C6CA-5E9A-A461-E4822EB9E76F"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FBFA1B23-C6CA-5E9A-A461-E4822EB9E76F"><!-- --></a><h2 class="sectiontitle">Creating a
shared chunk</h2> <p>A shared chunk can be created only by code running
on the kernel-side. This means that it is the device driver's responsibility
to create a chunk that is to be shared by user-side code. There is <em>no user-side
API</em> that allows user-side code to create shared chunks. </p>
 <p>The device
driver creates a shared chunk using the <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F8D1FB29-7238-3438-951A-6F853C7CF817"><span class="apiname">Kern::ChunkCreate()</span></a> function.
It passes to this function a <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html"><span class="apiname">TChunkCreateInfo</span></a> object containing
the required attributes for that chunk. The most important attribute is the <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html#GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4__GUID-B00A3693-50B6-3A84-89E0-B06D9ABE82ED"><span class="apiname">TChunkCreateInfo::ESharedKernelMultiple</span></a> attribute
that states that a shared chunk is to be created. </p>
 <p>Chunks are reference
counted kernel objects. When the chunk is created, the reference count is
set to one. </p>
 <p>See <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D284D6D0-400D-53D2-9A43-05CEE28DFDC4">Example:
Creating a shared chunk</a>. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D55514EA-D218-52F2-807B-78D58E99D810"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D55514EA-D218-52F2-807B-78D58E99D810"><!-- --></a><h2 class="sectiontitle">Opening a handle
to the shared chunk for user-side access</h2> <p>Before user-side code
can access the memory in a shared chunk, the device driver must create a handle
to the chunk and then pass the value back to the user-side. It does this by
calling the <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-BA56B205-60D8-326E-8340-3F78CCEA3DD1"><span class="apiname">Kern::MakeHandleAndOpen()</span></a> function, passing
the information: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-178CFDE6-BBB0-5A37-A680-13F4E0463248"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-178CFDE6-BBB0-5A37-A680-13F4E0463248"><!-- --></a><p>a pointer to the user-side
code's thread (or NULL if referring to the current thread) </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7A39F8FA-B7E8-5E27-BA07-D1CA6179B8BF"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7A39F8FA-B7E8-5E27-BA07-D1CA6179B8BF"><!-- --></a><p>a pointer to the shared
chunk </p>
 </li>

</ul>
 <p>Typically, the device driver does this in response to a request from
the user-side. <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-BA56B205-60D8-326E-8340-3F78CCEA3DD1"><span class="apiname">Kern::MakeHandleAndOpen()</span></a> also maps the
chunk's memory into the address space of the user-side code's thread. </p>
 <p>If
the creation of the handle is successful, the device driver returns the handle <em>value</em> back
to the user-side. The user-side code then assigns the value to an <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> object
using one of <samp class="codeph">RChunk</samp>'s base class functions: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-091419E2-3BA4-5821-8138-A1047A6070BF"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-091419E2-3BA4-5821-8138-A1047A6070BF"><!-- --></a><p> <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html#GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB__GUID-C7E88CD7-A32B-3585-9D8B-3A0726947690"><span class="apiname">RHandleBase::SetHandle()</span></a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7974DC49-8CDA-5660-9C8D-709D1FDCA478"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7974DC49-8CDA-5660-9C8D-709D1FDCA478"><!-- --></a><p> <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html#GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB__GUID-9AEAD2B5-4531-3157-839C-CBAECBFCF069"><span class="apiname">RHandleBase::SetReturnedHandle()</span></a>  </p>
 </li>

</ul>
 <p>The user-side code uses <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html#GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB__GUID-9AEAD2B5-4531-3157-839C-CBAECBFCF069"><span class="apiname">RHandleBase::SetReturnedHandle()</span></a> if
the device driver returns either a positive handle value or a negative error
code. A negative error code means that handle creation has failed. </p>
 <p>Opening
a handle to a shared chunk increases the reference count by one. </p>
 <p>See <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6501F90A-5330-5BC9-A991-A3BECCCA6CDD">Example:
Opening a handle to the shared chunk for user-side access</a>. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F63A506B-1573-5F6A-B0C7-CEE5BF1FAD72"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F63A506B-1573-5F6A-B0C7-CEE5BF1FAD72"><!-- --></a><h2 class="sectiontitle">Closing a handle</h2> <p>After
it has been opened, a device driver may need to perform further operations
before the handle can be returned to the user-side. If these operations fail,
the device driver code may want to unwind the processing it has done, including
discarding the handle it has just created. It does this using the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-71A20F01-5E5F-3B27-92BA-3B3BF7D578C9"><span class="apiname">Kern::CloseHandle()</span></a>. </p>
 <p>This
reverses the operation performed by <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-BA56B205-60D8-326E-8340-3F78CCEA3DD1"><span class="apiname">Kern::MakeHandleAndOpen()</span></a>. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-86446948-6012-59B9-8411-BF0E98DC7D3A"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-86446948-6012-59B9-8411-BF0E98DC7D3A"><!-- --></a><h2 class="sectiontitle">Closing and
destroying a shared chunk</h2> <p>There is no explicit method for deleting
or destroying shared chunks. Instead, because chunks are reference counted
kernel objects, a device driver can use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-480F655A-5B93-3E8A-8964-3A04682C3CCF"><span class="apiname">Kern::ChunkClose()</span></a>.
This function decrements a chunk's access count, and, if the count reaches
zero, the chunk is scheduled for destruction. </p>
 <p>The chunk is not be
destroyed immediately. Instead it is done asynchronously. If the device driver
needs to know when the chunk has been destroyed, it must specify a DFC (Deferred
Function Call) at the time the chunk is created. The device driver specifies
the DFC through the <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html#GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4__GUID-58271733-146A-3ECB-91AC-C38BD2ADC9A0"><span class="apiname">TChunkCreateInfo::iDestroyedDfc</span></a> member.
The DFC is queued to run only when the chunk has finally been destroyed. At
this point it is guaranteed that the memory mapped by the chunk can no longer
be accessed by any code. This is useful in cases where chunks are used to
map I/O devices or other special memory, and the program managing these needs
to know when they are free to be reused. </p>
 <p> <strong> Note:</strong> For each call
to <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F8D1FB29-7238-3438-951A-6F853C7CF817"><span class="apiname">Kern::ChunkCreate()</span></a> and <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-DAEE47C8-40ED-3F95-9EE9-29033FC5A8D3"><span class="apiname">Kern::OpenSharedChunk()</span></a> there
should be <em>exactly one</em> call to <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-480F655A-5B93-3E8A-8964-3A04682C3CCF"><span class="apiname">Kern::ChunkClose()</span></a>.
Calling <samp class="codeph">Close()</samp> too few times can cause memory leaks. Calling <samp class="codeph">Close()</samp> too
many times can cause the chunk to be destroyed while a program is still trying
to access the memory, which causes an application panic for user code and
a system crash for kernel code. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6D3AAC95-E52B-5E78-B57E-0433ECF14C3A"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6D3AAC95-E52B-5E78-B57E-0433ECF14C3A"><!-- --></a><h2 class="sectiontitle">Committing
memory</h2> <p>After a shared chunk has been created it owns a region of
contiguous virtual addresses. This region is empty, which means that it is
not mapped to any physical RAM or memory mapped I/O devices. </p>
 <p>Before
the chunk can be used, the virtual memory must be mapped to real physical
memory. This is known as <em>committing</em> memory. </p>
 <p><strong>Committing RAM
from the system free memory pool</strong> </p>
 <p>You can commit RAM taken from
the system free memory pool using the following ways: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7E755F49-D5E6-538C-9CE1-947310DD94A7"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7E755F49-D5E6-538C-9CE1-947310DD94A7"><!-- --></a><p>by committing an arbitrary
set of pages. Use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-9FCD7C2A-5192-3B99-8ACF-2802C1A3FAA1"><span class="apiname">Kern::ChunkCommit()</span></a>. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-738B8FF3-5848-54F9-B872-179317BE9B4B"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-738B8FF3-5848-54F9-B872-179317BE9B4B"><!-- --></a><p>by committing a set
of pages with physically contiguous addresses. Use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-E1B88A30-6572-3E0B-B6BB-ED4359D7A5FD"><span class="apiname">Kern::ChunkCommitContiguous()</span></a>. </p>
 </li>

</ul>
 <p><strong>Committing specified physical addresses</strong> </p>
 <p>You can commit
specific physical addresses, but only if you set the data member <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html#GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4__GUID-106850A0-5498-387F-AF70-F9D04EB6318D"><span class="apiname">TChunkCreateInfo::iOwnsMemory</span></a> to <a href="GUID-A759CA2D-8327-348F-9337-4886E619D920.html"><span class="apiname">EFalse</span></a> when
you create the shared chunk - see <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FBFA1B23-C6CA-5E9A-A461-E4822EB9E76F">Creating
a shared chunk</a>. </p>
 <p>You can use the following ways to do this: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-2DCE4AB8-A5CF-536C-8FC1-414755AAC894"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-2DCE4AB8-A5CF-536C-8FC1-414755AAC894"><!-- --></a><p>by committing a region
of contiguous addresses. Use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F3A3D9F5-5885-38B2-9711-1DF99C36F62D"><span class="apiname">Kern::ChunkCommitPhysical()</span></a> with
the signature: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E159781F-7B60-5A2B-A8EE-3BB6B9CEADBB"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E159781F-7B60-5A2B-A8EE-3BB6B9CEADBB"><!-- --></a>TInt Kern::ChunkCommitPhysical(DChunk*, TInt, TInt, TUint32)</pre>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-5CC4AB75-BF24-5C86-B87B-CA4CDFF6ED5E"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-5CC4AB75-BF24-5C86-B87B-CA4CDFF6ED5E"><!-- --></a><p>by committing an arbitrary
set of physical pages. Use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F3A3D9F5-5885-38B2-9711-1DF99C36F62D"><span class="apiname">Kern::ChunkCommitPhysical()</span></a> with
the signature: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-321BD1CC-95D4-5539-9C24-187944AA9D90"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-321BD1CC-95D4-5539-9C24-187944AA9D90"><!-- --></a>TInt Kern::ChunkCommitPhysical(DChunk*, TInt, TInt, const TUint32*)</pre>
 </li>

</ul>
 <p>Note: the same physical memory can be committed to two different <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> s
or shared chunks at the same time, where each <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> has
a different owner, as long as your turn OFF the caches. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E9630D2D-794B-5AB1-8980-0927E040C0C5"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E9630D2D-794B-5AB1-8980-0927E040C0C5"><!-- --></a><h2 class="sectiontitle">Passing data
from user-side code to another device driver</h2> <p>User-side code that
has access to a shared chunk from one device driver may want to use this when
it communicates with another device driver. To enable this, the second device
driver needs to gain access to the chunk and the addresses used by the memory
it represents. </p>
 <p>The second driver must open a handle on the shared
chunk before any of its code can safely access the memory represented by that
chunk. Once it has done this, the reference counted nature of chunks means
that the chunk, and the memory it represents, remains accessible until the
chunk is closed. </p>
 <p>The general pattern is: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-03CA36B3-E327-5632-BAC4-80386B6EADC5"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-03CA36B3-E327-5632-BAC4-80386B6EADC5"><!-- --></a><p>the first device driver
creates the shared chunk. </p>
 <p>See <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FBFA1B23-C6CA-5E9A-A461-E4822EB9E76F">Creating
a shared chunk</a>. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-510CA2F2-B9D5-5342-8739-566EBC0BAAC9"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-510CA2F2-B9D5-5342-8739-566EBC0BAAC9"><!-- --></a><p>the user-side gets the
handle <em>value</em> from the first device driver and calls <samp class="codeph">SetHandle()</samp> or <samp class="codeph">SetReturnedHandle()</samp> on
an <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> object [the functions are members of <samp class="codeph">RChunk</samp>'s
base class <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html"><span class="apiname">RHandleBase</span></a> (see <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html#GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB__GUID-C7E88CD7-A32B-3585-9D8B-3A0726947690"><span class="apiname">RHandleBase::SetHandle()</span></a> and <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html#GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB__GUID-9AEAD2B5-4531-3157-839C-CBAECBFCF069"><span class="apiname">RHandleBase::SetReturnedHandle()</span></a>]. </p>
 <p>See <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D55514EA-D218-52F2-807B-78D58E99D810">Opening
a handle to the shared chunk for user-side access</a>. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3FFCE699-19F1-5A35-BEE6-96FB706EC16F"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3FFCE699-19F1-5A35-BEE6-96FB706EC16F"><!-- --></a><p>the user-side passes
the handle <em>value</em> to the second device driver. This value is obtained
by calling <samp class="codeph">Handle()</samp> on the <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> object.
[the function is a member of <samp class="codeph">RChunk</samp>'s base class <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html"><span class="apiname">RHandleBase</span></a> (see <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html#GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB__GUID-5B4C908D-AA34-3F1A-8170-77C4C1F829F0"><span class="apiname">RHandleBase::Handle()</span></a>]. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8337612F-E476-52BC-8A4F-39099DD0F351"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8337612F-E476-52BC-8A4F-39099DD0F351"><!-- --></a><p>the second device driver
calls the variant of <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-DAEE47C8-40ED-3F95-9EE9-29033FC5A8D3"><span class="apiname">Kern::OpenSharedChunk()</span></a> with the signature: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9B2095EE-14E9-5E05-8CD4-67DCB62E3583"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9B2095EE-14E9-5E05-8CD4-67DCB62E3583"><!-- --></a>DChunk* Kern::OpenSharedChunk(DThread*,TInt,TBool)</pre>
 <p>to
open a handle to the shared chunk. </p>
 <p> <strong> Note:</strong> there are situations
where the second device driver cannot use this variant of <samp class="codeph">Kern::OpenSharedChunk()</samp> because: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FDAE7AC0-17AF-5EF8-BEE1-9B58A97B4283"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FDAE7AC0-17AF-5EF8-BEE1-9B58A97B4283"><!-- --></a><p>The user-side application
may have obtained data by using a library API that uses shared chunks internally,
but which only presents a descriptor based API to the user application. For
example, an image conversion library may perform JPEG decoding using a DSP,
which puts its output into a shared chunk, but that library supplies the user
application with only a descriptor for the decoded data, not a chunk handle. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-45844589-86D5-5FB8-AEA7-D5586DA45E87"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-45844589-86D5-5FB8-AEA7-D5586DA45E87"><!-- --></a><p>The communication channel
between the user-side application and the device driver supports descriptor
based APIs only, and does not have an API specifically for shared chunks.
The API items presented by the File Server are an example of this situation. </p>
 </li>

</ul>
 <p>The second device driver will only have the address and size of the
data (usually a descriptor). If the driver needs to optimise the case where
it knows that this data resides in a shared chunk, it can use the variant
of <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-DAEE47C8-40ED-3F95-9EE9-29033FC5A8D3"><span class="apiname">Kern::OpenSharedChunk()</span></a> with the signature: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8CCA35C1-ABBE-5C9D-ABB9-0233E074A14F"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8CCA35C1-ABBE-5C9D-ABB9-0233E074A14F"><!-- --></a>DChunk* Kern::OpenSharedChunk(DThread*,const TAny*,TBool,TInt&amp;)</pre>
 <p>to
speculatively open the chunk. </p>
 </li>

</ul>
 <p><strong>Getting the virtual address of data in a shared chunk </strong> </p>
 <p>Before
device driver code can access a shared chunk that is has opened, it must get
the address of the data within it. Typically, user-side code will pass offset
and size values to the driver. The driver converts this information into an
address, using the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-626CCD99-63D8-322A-A807-9DB96523C82D"><span class="apiname">Kern::ChunkAddress()</span></a>. </p>
 <p><strong>Getting
the physical address of data in a shared chunk </strong> </p>
 <p>Device driver
code can get the physical address of a region within a shared chunk from the
offset into the chunk and a size value. This is useful for DMA or any other
task that needs a physical address. Use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-79F110C1-2764-34B5-857B-6C0012D2049D"><span class="apiname">Kern::ChunkPhysicalAddress()</span></a> to
do this. </p>
 <p><strong>Getting chunk attributes and checking for uncommitted
memory </strong> </p>
 <p>As a shared chunk may contain uncommitted regions of memory
(gaps), it is important that these gaps are detected. Any attempt to access
a bad address causes an exception. You can use the function <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-79F110C1-2764-34B5-857B-6C0012D2049D"><span class="apiname">Kern::ChunkPhysicalAddress()</span></a> to
check for uncommitted regions of memory. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-4C374CF0-0680-5A27-94E7-BB0FD75413AF"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-4C374CF0-0680-5A27-94E7-BB0FD75413AF"><!-- --></a><h2 class="sectiontitle">Passing data
between user-side code</h2> <p>User-side code can access data in a shared
chunk once it has opened a handle on that chunk. Handles can be passed between
user processes using the various handle passing functions. This most common
scenario is via client-server Inter Process Communication (IPC). </p>
 <p><strong>Passing
a handle from client to server </strong> </p>
 <p>The client passes the handle to
the shared chunk as one of the four arguments in a <a href="GUID-4AD02F14-1142-372F-9D11-224595932034.html"><span class="apiname">TIpcArgs</span></a> object.
The server opens this using the <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html#GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07__GUID-BE5915FF-4C43-30D8-A6E3-45C33973CD9D"><span class="apiname">RChunk::Open()</span></a> variant
with the signature: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-0AFB6DCA-A689-55CD-8B51-18E001822855"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-0AFB6DCA-A689-55CD-8B51-18E001822855"><!-- --></a>RChunk::Open(RMessagePtr2 aMessage,TInt aParam,TBool isReadOnly, TOwnerType aType)
</pre>
 <p><strong>Passing a handle from server to client </strong> </p>
 <p>The
server completes the client message using the chunk handle: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8CBBC765-9623-508D-8761-A123A4697C7C"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8CBBC765-9623-508D-8761-A123A4697C7C"><!-- --></a>RMessagePtr2::Complete(RHandleBase aHandle)</pre>
 <p>The
client then assigns the returned handle value to an <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> by
calling: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-EC9CE7E0-20B2-5315-9770-0860A3C429DA"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-EC9CE7E0-20B2-5315-9770-0860A3C429DA"><!-- --></a>RChunk::SetReturnedHandle(TInt aHandleOrError)</pre>
 <p> <strong> Note:</strong>  </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B32E3982-9AC8-531E-9109-3CA77F75D4F4"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B32E3982-9AC8-531E-9109-3CA77F75D4F4"><!-- --></a><p>Processes that share
data within shared chunks must specify the address of that data as an <em>offset</em> from
the start of the chunk, and not as an absolute address. This is because the
chunk may appear at different addresses in the address spaces of different
user processes. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-BD87DA45-3279-522C-BF23-552A40DFB8FD"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-BD87DA45-3279-522C-BF23-552A40DFB8FD"><!-- --></a><p>Once a chunk is no longer
needed for data sharing, user applications should close the handle they have
on it. If they do not, the memory mapped by the chunk can never be freed. </p>
 </li>

</ul>
 <p>See <a href="GUID-6047DB3F-DC92-51DF-9EEB-00E79E890B54.html">Using
Client/Server</a>. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A8FF0519-9FDC-53D5-8BD6-A3AEA6BFDD46"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A8FF0519-9FDC-53D5-8BD6-A3AEA6BFDD46"><!-- --></a><h2 class="sectiontitle">Direct peripheral
access to shared chunks</h2> <p>When DMA or any other hardware device accesses
the physical memory represented by a shared chunk, the contents of CPU memory
cache(s) must be synchronised with that memory. Use these functions for this
purpose: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F1BB9CD1-2D18-5B85-B2DC-C3189C2A82CB"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F1BB9CD1-2D18-5B85-B2DC-C3189C2A82CB"><!-- --></a><p> <a href="GUID-4425E698-EE8A-369B-92CD-09B1CBD2911F.html#GUID-4425E698-EE8A-369B-92CD-09B1CBD2911F__GUID-5F08DEAA-1237-32DE-AE41-CE7B18230972"><span class="apiname">Cache::SyncMemoryBeforeDmaWrite()</span></a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-89FE8A8C-BD27-5A9C-A429-7600CDF2CD76"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-89FE8A8C-BD27-5A9C-A429-7600CDF2CD76"><!-- --></a><p> <a href="GUID-4425E698-EE8A-369B-92CD-09B1CBD2911F.html#GUID-4425E698-EE8A-369B-92CD-09B1CBD2911F__GUID-3FF3C567-C1BD-3D4E-97E1-B036456A374E"><span class="apiname">Cache::SyncMemoryBeforeDmaRead()</span></a>  </p>
 </li>

</ul>
 <p> <strong> Note:</strong> both these functions take a <a href="GUID-F58A1C0D-1B36-37EA-8012-1C74B2D12CAD.html"><span class="apiname">TUint32</span></a> type
parameter, identified in the function signatures as <samp class="codeph">TUint32 aMapAttr</samp>.
This is the same <samp class="codeph">TUint32</samp> value set on return from calls to
either <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-79F110C1-2764-34B5-857B-6C0012D2049D"><span class="apiname">Kern::ChunkPhysicalAddress()</span></a> or <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F8D1FB29-7238-3438-951A-6F853C7CF817"><span class="apiname">Kern::ChunkCreate()</span></a>. </p>
 </div>

<div class="section" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D8E298EA-A4CD-5501-B5F1-B8F0EE93CE84"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D8E298EA-A4CD-5501-B5F1-B8F0EE93CE84"><!-- --></a><h2 class="sectiontitle">Example code</h2> <p>This
section contains code snippets that show shared chunks in use. Most of the
code is intended to be part of a device driver. A few snippets show user-side
code and the interaction with device driver code. </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F2F06E9B-4832-5E05-B392-EC0B89CC2813"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F2F06E9B-4832-5E05-B392-EC0B89CC2813"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D284D6D0-400D-53D2-9A43-05CEE28DFDC4">Example: Creating a shared chunk</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9807283B-B66D-59BE-A6E3-6A9E0A62021D"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9807283B-B66D-59BE-A6E3-6A9E0A62021D"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6501F90A-5330-5BC9-A991-A3BECCCA6CDD">Example: Opening a handle to the shared chunk for user-side access</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3C59E7E6-FA0C-5487-BEC8-FCA4BBE2524F"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3C59E7E6-FA0C-5487-BEC8-FCA4BBE2524F"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-062C405B-B10F-54A8-8F61-418CAE6019D8">Example: using a DFC to notify destruction of chunk</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9FF13AA3-5847-5574-8B0F-81123EB446BE"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9FF13AA3-5847-5574-8B0F-81123EB446BE"><!-- --></a><p> <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-97BF15A2-E74A-51DE-B003-16E1DFF8964E">Example: committing memory</a>  </p>
 </li>

</ul>
 <p id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D284D6D0-400D-53D2-9A43-05CEE28DFDC4"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D284D6D0-400D-53D2-9A43-05CEE28DFDC4"><!-- --></a><strong>Example: Creating
a shared chunk</strong> </p>
 <p>This code snippet shows how a device driver creates
a shared chunk. The class <samp class="codeph">DMyDevice</samp> has been given responsibility
for creating the chunk: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FD2DE166-0516-529A-BD0E-8A872968A67A"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-FD2DE166-0516-529A-BD0E-8A872968A67A"><!-- --></a>/**
The device or other object making use of shared chunks
*/
class DMyDevice
    {
    ...
    TInt CreateChunk();
    void CloseChunk();
private:
    void ChunkDestroyed();
private:
    TBool iMemoryInUse;
    DChunk* iChunk
    TUint32 iChunkMapAttr;
    TLinAddr iChunkKernelAddr;
    ...
    }</pre>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-40DB5E59-11DC-5FC5-B36A-6766132C9A65"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-40DB5E59-11DC-5FC5-B36A-6766132C9A65"><!-- --></a>/*
Address and size of our device's memory
*/
const TPhysAddr KMyDeviceAddress = 0xc1000000;  // Physical address
const TInt KMyDeviceMemorySize = 0x10000;

/**
Create a chunk which maps our device's memory
*/
TInt DMyDevice::CreateChunk()
    {
    // Check if our device's memory is already in use
    if(iMemoryInUse)
        {
        // Wait for short while (200ms) in case chunk is being deleted
        NKern::Sleep(NKern::TimerTicks(200));
        // Check again
        if(iMemoryInUse)
            {
            // Another part of the system is probably still using our memory, so...
            return KErrInUse;
            }
        }

    // Enter critical section so we can't die and leak the objects we are creating
    // I.e. the TChunkCleanup and DChunk (Shared Chunk)
    NKern::ThreadEnterCS();

    // Create chunk cleanup object
    TChunkCleanup* cleanup = new iChunkCleanup(this);
    if(!cleanup)
        {
        NKern::ThreadLeaveCS();
        return KErrNoMemory;
        }

    // Create the chunk
    TChunkCreateInfo info;
    info.iType         = TChunkCreateInfo::ESharedKernelMultiple;
    info.iMaxSize      = KMyDeviceMemorySize;
    info.iMapAttr      = EMapAttrFullyBlocking; // No caching
    info.iOwnsMemory   = EFalse; // We'll be using our own devices memory
    info.iDestroyedDfc = cleanup;
    DChunk* chunk;
    TInt r = Kern::ChunkCreate(info, chunk, iChunkKernelAddr, iChunkMapAttr);
    if(r!=KErrNone)
        {
        delete cleanup;
        NKern::ThreadLeaveCS();
        return r;
        }

    // Map our device's memory into the chunk (at offset 0)

    r = Kern::ChunkCommitPhysical(chunk,0,KMyDeviceMemorySize,KMyDeviceAddress);
    if(r!=KErrNone)
        {
        // Commit failed so tidy-up...

        // We, can't delete 'cleanup' because it is now owned by the chunk and will
        // get run when the chunk is destroyed. Instead, we have to Cancel it, which
        // prevents it from doing anything when it does run.
        cleanup-&gt;Cancel()
        // Close chunk, which will then get deleted at some point
        Kern::ChunkClose(chunk);
        }
    else
        {
        // Commit succeeded so flag memory in use and store chunk pointer
        iMemoryInUse = ETrue;
        iChunk = chunk;
        }

    // Can leave critical section now that we have saved pointers to created objects
    NKern::ThreadLeaveCS();

    return r;
    }

/**
Close the chunk which maps our device's memory
*/
TInt DMyDevice::CloseChunk()
    {
    // Enter critical section so we can't die whilst owning the chunk pointer
    NKern::ThreadEnterCS();

    // Atomically get pointer to our chunk and NULL the iChunk member
    DChunk* chunk = (DChunk*)NKern::SafeSwap(NULL,(TAny*&amp;)iChunk);

    // Close chunk
    if(chunk)
       Kern::CloseChunk(chunk);

    // Can leave critical section now
    NKern::ThreadLeaveCS();
    }
</pre>
 <p><strong>Implementation notes </strong> </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A587088F-889D-58F7-973D-AD6C471B43E2"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A587088F-889D-58F7-973D-AD6C471B43E2"><!-- --></a><p>a <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html"><span class="apiname">TChunkCreateInfo</span></a> object
is created, populated and passed to <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F8D1FB29-7238-3438-951A-6F853C7CF817"><span class="apiname">Kern::ChunkCreate()</span></a>.
This is information that Symbian platform needs to create the chunk. To create
a <em>shared</em> chunk, <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html#GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4__GUID-4384AF76-CECE-3B86-BE92-375C1DEA36DA"><span class="apiname">TChunkCreateInfo::iType</span></a> must be
set to <a href="GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4.html#GUID-51F7DBCF-BFB6-31F9-8882-5D263A1AD4B4__GUID-B00A3693-50B6-3A84-89E0-B06D9ABE82ED"><span class="apiname">TChunkCreateInfo::ESharedKernelMultiple</span></a>. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F2EB6952-CAFA-5CB0-BB86-3C77C46C9EEA"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F2EB6952-CAFA-5CB0-BB86-3C77C46C9EEA"><!-- --></a><p>If the device architecture
allowed the device driver function <samp class="codeph">DMyDevice::CreateChunk()</samp> to
be called in a re-entrant manner, you would need to protect this code using
a mutex. Such a situation might arise when a logical channel is shared between
two threads, or two logical channels are created on the same device. There
may also be other cases where a mutex is needed. </p>
 <p>See also: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B5A971C3-B630-5944-851C-86D4285D3C90"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B5A971C3-B630-5944-851C-86D4285D3C90"><!-- --></a><p> <a href="GUID-EAA6A9FB-A470-550C-B7B4-FF68A733A2D5.html#GUID-EAA6A9FB-A470-550C-B7B4-FF68A733A2D5__GUID-F5B59A23-48E0-5596-B589-10DD2549F124">The Symbian platform mutex</a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-0618C6AD-DB19-50A6-979B-D2D7C7CA0413"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-0618C6AD-DB19-50A6-979B-D2D7C7CA0413"><!-- --></a><p> <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-FEBBDA4F-412E-3AE5-9098-8E2F6BF3E969"><span class="apiname">Kern::MutexCreate()</span></a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7FA55315-7403-5CAD-9E84-73A7F8D3DF3A"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-7FA55315-7403-5CAD-9E84-73A7F8D3DF3A"><!-- --></a><p> <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-1F0C28A8-9E9A-3AA3-A441-BA8406B3A06A"><span class="apiname">Kern::MutexWait()</span></a>  </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3DC20F30-767F-5D3F-8013-2976AB6B2991"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3DC20F30-767F-5D3F-8013-2976AB6B2991"><!-- --></a><p> <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-B8080F86-1342-31EA-9A28-205354CA0CB9"><span class="apiname">Kern::MutexSignal()</span></a>  </p>
 </li>

</ul>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A68113CF-C792-59A7-94C3-D2214E065CF6"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-A68113CF-C792-59A7-94C3-D2214E065CF6"><!-- --></a><p>The line: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-519F054D-429E-5B64-B8FA-34F48E85E1B9"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-519F054D-429E-5B64-B8FA-34F48E85E1B9"><!-- --></a>info.iDestroyedDfc = cleanup;</pre>
 <p>in
the function <samp class="codeph">DMyDevice::CreateChunk()</samp> and code following
the comment </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-C1FCC780-1BD1-5E29-9089-B59434804335"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-C1FCC780-1BD1-5E29-9089-B59434804335"><!-- --></a>// Create chunk cleanup object</pre>
 <p>sets
the DFC that runs when the shared chunk is finally closed. See <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-062C405B-B10F-54A8-8F61-418CAE6019D8">Example: using a DFC to notify destruction of chunk</a> for the DFC code
itself. </p>
 </li>

</ul>
 <p id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6501F90A-5330-5BC9-A991-A3BECCCA6CDD"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-6501F90A-5330-5BC9-A991-A3BECCCA6CDD"><!-- --></a><strong>Example: Opening
a handle to the shared chunk for user-side access</strong> </p>
 <p>These code snippets
show user-side code making a request to a device driver to open handles on
two shared chunks. </p>
 <p>The code snippets assume that the chunks have already
been created. </p>
 <p><strong>User-side</strong> </p>
 <p>The user-side interface to
a device driver is always a class derived from <a href="GUID-6FBFA078-8253-3E24-B1F8-5F75E86C3066.html"><span class="apiname">RBusLogicalChannel</span></a>,
and is provided by the device driver. Here, this is the <samp class="codeph">RMyDevice</samp> class.
In real code, the class would offer much more functionality, but only the
relevant function members and data members are shown: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-CB639C9A-900F-5344-B50F-7DC190D714EB"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-CB639C9A-900F-5344-B50F-7DC190D714EB"><!-- --></a>/**
Client (user-side) interface to the device driver.
*/
class RMyDevice : public RBusLogicalChannel
    {
    ...
public:
    TInt OpenIoChunks(RChunk&amp; aInputChunk,RChunk&amp; aOutputChunk);
    ... 
private:
    /** Structure to hold information about the i/o buffers */
    class TIoChunkInfo
        {
    public:
        TInt iInputChunkHandle;
        TInt iOutputChunkHandle;
        };
    // Kernel-side channel class is a friend...
    friend class DMyDeviceChannel; 
    ...
    };
</pre>
 <p>You call the function <samp class="codeph">OpenIoChunks()</samp> to: </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-46625099-EA5D-519C-A9F3-BC6AD97AB41A"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-46625099-EA5D-519C-A9F3-BC6AD97AB41A"><!-- --></a><p>issue a request to the
driver to create handles to two chunks </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-BAA515D0-FA3A-5D6B-807C-5B562E8B9387"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-BAA515D0-FA3A-5D6B-807C-5B562E8B9387"><!-- --></a><p>get handles to those
shared chunks so that they can be accessed by user-side code. </p>
 </li>

</ul>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-42B88530-E7A7-5F5D-A9D4-2026E3E4F3E4"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-42B88530-E7A7-5F5D-A9D4-2026E3E4F3E4"><!-- --></a>TInt RMyDevice::OpenIoChunks(RChunk&amp; aInputChunk,RChunk&amp; aOutputChunk)
    {
    // Send request to driver to create chunk handles.
    TIoChunkInfo info;
    TInt r=DoControl(EOpenIoChunks,(TAny*)&amp;info);
    // Set the handles for the chunks
    aInputChunk.SetHandle(info.iInputChunkHandle);
    aOutputChunk.SetHandle(info.iOutputChunkHandle);

    return r;
    }
</pre>
 <p><strong>Implementation notes </strong> </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3758237B-4806-5852-835C-1288F368BBEE"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3758237B-4806-5852-835C-1288F368BBEE"><!-- --></a><p>The request is passed
to the driver as a synchronous call; it calls the base class function <a href="GUID-6FBFA078-8253-3E24-B1F8-5F75E86C3066.html#GUID-6FBFA078-8253-3E24-B1F8-5F75E86C3066__GUID-D774DE92-6431-374A-A1F6-1C7045BD4FE5"><span class="apiname">RBusLogicalChannel::DoControl()</span></a>.
This means that the call does not return until the driver has created (or
failed to create) the handles to the shared chunks. The call is synchronous
because the creation of the handles does not depend on the hardware controlled
by the driver, so there should be minimal delay in its execution. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F8E261B0-D768-5157-B6FA-6B51B6829E47"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F8E261B0-D768-5157-B6FA-6B51B6829E47"><!-- --></a><p>The driver returns the
handle <em>numbers</em> in the <samp class="codeph">TIoChunkInfo</samp> object; specifically
in its <samp class="codeph">iInputChunkHandle</samp> and <samp class="codeph">iOutputChunkHandle</samp> data
members. </p>
 <p>To access the shared chunks, user-side code needs handles
to them. Handles to chunks are <a href="GUID-326A2F4D-0E99-31C0-A35D-E8BF45913F07.html"><span class="apiname">RChunk</span></a> objects. </p>
 <p>The
final step is to set the returned handle <em>numbers</em> into the <samp class="codeph">RChunk</samp> objects
by calling <samp class="codeph">SetHandle()</samp>. This function is provided by <samp class="codeph">RChunk</samp>'s
base class <a href="GUID-727D2B62-09A9-3CBC-AB6F-591E52EC68EB.html"><span class="apiname">RHandleBase</span></a>. </p>
 <p>See <a href="GUID-2EAAE194-FAE1-5545-A678-72973E9B72A7.html">handles</a> for
background information. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-57FFB715-A05B-5E0D-8354-094018C5AEE5"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-57FFB715-A05B-5E0D-8354-094018C5AEE5"><!-- --></a><p>In this example the
return value from <a href="GUID-6FBFA078-8253-3E24-B1F8-5F75E86C3066.html#GUID-6FBFA078-8253-3E24-B1F8-5F75E86C3066__GUID-D774DE92-6431-374A-A1F6-1C7045BD4FE5"><span class="apiname">RBusLogicalChannel::DoControl()</span></a> is not
checked. In practice you need to do so. </p>
 </li>

</ul>
 <div class="fignone" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-2D81B150-2273-5474-9E33-2C7CE236FAD8"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-2D81B150-2273-5474-9E33-2C7CE236FAD8"><!-- --></a><span class="figcap">Figure 1. Shared chunks implementation</span>

<img src="GUID-52B8098A-7695-5EA6-B58F-D730A445C583_d0e308348_href.png"/>
</div>
 <p><strong> Device driver (kernel) side </strong> </p>
 <p>This is example code
snippet shows the device driver side handling of the request made by the user-side
to open handles on two shared chunks. </p>
 <p>The request is handled by the <samp class="codeph">OpenIoChunks()</samp> function
in the device driver's logical channel. The logical channel is represented
by a class derived from <a href="GUID-E7550422-5121-3393-A85E-BB797969CD2A.html"><span class="apiname">DLogicalChannelBase</span></a>. In this example,
this is the <samp class="codeph">DMyDeviceChannel</samp> class. </p>
 <p>Details of how
a user-side call to <samp class="codeph">RMyDevice::OpenIoChunks()</samp> results in
a call to the driver's <samp class="codeph">DMyDeviceChannel::OpenIoChunks()</samp> function
are not shown. <a href="GUID-0956CE5E-C02B-5EEE-890A-5E8E84A8D9A1.html#GUID-0956CE5E-C02B-5EEE-890A-5E8E84A8D9A1__GUID-AB757BD9-80A4-53DE-82D8-D9BE8A252C9F">Passing
requests from user-side to kernel-side</a> in <a href="GUID-0956CE5E-C02B-5EEE-890A-5E8E84A8D9A1.html">The
Logical Channel</a> explains the principles. </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B55DA6B8-A38F-5ED6-A415-DBB027D30870"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B55DA6B8-A38F-5ED6-A415-DBB027D30870"><!-- --></a>/**
  Kernel-side Logical Channel for 'MyDevice'
*/
class DMyDeviceChannel : public DLogicalChannelBase
    {
    ...
private:
    TInt OpenIoChunks(RMyDevice::TIoChunkInfo* aIoChunkInfoForClient);
private:
    DChunk* iInputChunk;
    TInt iInputChunkSize;
    DChunk* iOutputChunk;
    TInt iOutputChunkSize;
    ...
    };
</pre>
 <p>The following code snippet is the implementation of <samp class="codeph">DMyDeviceChannel::OpenIoChunks()</samp>. </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E344116F-8C10-5226-9547-5F0ABD16D831"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-E344116F-8C10-5226-9547-5F0ABD16D831"><!-- --></a>/**
  Called by logical channel to service a client request for i/o chunk handles
*/
TInt DMyDeviceChannel::OpenIoChunks(RMyDevice::TIoChunkInfo* aIoChunkInfo)
    {
    // Local info structure we will fill in
    RMyDevice::TIoChunkInfo info;

    // Need to be in critical section whilst creating handles
    NKern::ThreadEnterCS();

    // Make handle to iInputChunk for current thread
    TInt r = Kern::MakeHandleAndOpen(NULL, iInputChunk); 
    // r = +ve value for a handle, -ve value is error code
    if(r&gt;=0) 
        {
        // Store InputChunk handle
        info.iInputChunkHandle = r;

        // Make handle to iOutputChunk for current thread
        r = Kern::MakeHandleAndOpen(NULL, iOutputChunk); 
        // r = +ve value for a handle, -ve value is error code
        if(r&gt;=0) 
            {
            // Store OutputChunk handle
            info.iOutputChunkHandle = r;
            // Signal we succeeded...
            r = KErrNone;
            }
        else
            {
            // Error, so cleanup the handle we created for iInputChunk
            Kern::CloseHandle(NULL,info.iInputChunkHandle);
            }
        }

    // Leave critical section before writing info to client because throwing an
    // exception whilst in a critical section is fatal to the system.
    NKern::ThreadLeaveCS();

    // If error, zero contents of info structure.
    // (Zero is usually a safe value to return on error for most data types,
    // and for object handles this is same as KNullHandle)
    if(r!=KErrNone)
        memclr(&amp;info,sizeof(info));

    // Write info to client memory
    kumemput32(aIoChunkInfo,&amp;info,sizeof(info));

    return r;
    }
</pre>
 <p><strong>Implementation notes </strong> </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-396C4C6F-C6ED-5796-8B68-13A2E25FF365"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-396C4C6F-C6ED-5796-8B68-13A2E25FF365"><!-- --></a><p>The function calls <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-BA56B205-60D8-326E-8340-3F78CCEA3DD1"><span class="apiname">Kern::MakeHandleAndOpen()</span></a> twice,
once for each shared chunk. A NULL value is passed as the first parameter
in both calls to this function instead of an explicit <samp class="codeph">DThread</samp> object.
This creates the handles for the current thread. Although this code is running
in kernel mode, the context remains the user thread. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B0D3721A-A5A8-5A17-A402-C84A087DC921"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-B0D3721A-A5A8-5A17-A402-C84A087DC921"><!-- --></a><p>The first handle created
is closed if the second handle cannot be created: </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8B73E41A-8BEF-503A-8A22-13F2258BC380"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-8B73E41A-8BEF-503A-8A22-13F2258BC380"><!-- --></a>if(r&gt;=0) 
            {
            ...
            }
        else
            {
            // Error, so cleanup the handle we created for iInputChunk
            Kern::CloseHandle(NULL,info.iInputChunkHandle);
            }</pre>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-396AE759-ACC8-5F7E-AF36-37A7A2BDB855"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-396AE759-ACC8-5F7E-AF36-37A7A2BDB855"><!-- --></a><p>The handle values are
written back into the <samp class="codeph">TIoChunkInfo</samp> structure using the <a href="GUID-D141C3C4-F2F6-37DF-BDF6-63DDE9052FA0.html"><span class="apiname">kumemput32()</span></a> function.
See the EKA2 references in <a href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.html#GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39__GUID-4A7BCB91-C58B-597F-85B6-74463BE9BC04">Accessing
User Memory</a> in <a href="GUID-F46B87B7-97A9-530B-BAC4-EF1DB9C91E39.html">Migration
Tutorial: EKA1 Device Driver to Kernel Architecture 2</a>. </p>
 </li>

</ul>
 <p id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-062C405B-B10F-54A8-8F61-418CAE6019D8"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-062C405B-B10F-54A8-8F61-418CAE6019D8"><!-- --></a><strong>Example: Using
a DFC to notify destruction of a chunk</strong> </p>
 <p>This set of code snippets
shows how to set up a DFC that notifies a device driver when a shared chunk
has finally been destroyed. </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F75EE51B-EC55-57C1-B2C6-D68D44B34069"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-F75EE51B-EC55-57C1-B2C6-D68D44B34069"><!-- --></a>/**
Example class suitable for use as a 'Chunk Destroyed DFC' when
creating Shared Chunks with Kern::ChunkCreate()
*/
class TChunkCleanup : private TDfc
    {
public:
    TChunkCleanup(DMyDevice* aDevice);
    void Cancel();
private:
    static void ChunkDestroyed(TChunkCleanup* aSelf);
private:
    DMyDevice* iDevice;
    };

/**
Contruct a Shared Chunk cleanup object which will signal the specified device
when a chunk is destroyed.
*/
TChunkCleanup::TChunkCleanup(DMyDevice* aDevice)
    : TDfc((TDfcFn)TChunkCleanup::ChunkDestroyed,this,Kern::SvMsgQue(),0)
    , iDevice(aDevice)
    {}

/**
Cancel the action of the cleanup object.
*/
void TChunkCleanup::Cancel()
    {
    // Clear iDevice which means that when the DFC gets queued on chunk destruction
    // our ChunkDestroyed method will do nothing other than cleanup itself.
    iDevice = NULL;
    }

/**
Callback function called when the DFC runs, i.e. when a chunk is destroyed.
*/
void TChunkCleanup::ChunkDestroyed(TChunkCleanup* aSelf)
    {
    DMyDevice* device = aSelf-&gt;iDevice;
    // If we haven't been Cancelled...
    if(device)
        {
        // Perform any cleanup action required. In this example we call a method
        // on 'MyDevice' which encapsulates this.
        device-&gt;ChunkDestroyed();
        }

    // We've finished so now delete ourself
    delete aSelf;
    }
</pre>
 <p><strong>Implementation notes </strong> </p>
 <ul>
<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3387037D-9BBC-5A07-A180-FC2DAB6F6503"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-3387037D-9BBC-5A07-A180-FC2DAB6F6503"><!-- --></a><p>The DFC is an item of
information that is passed to <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-F8D1FB29-7238-3438-951A-6F853C7CF817"><span class="apiname">Kern::ChunkCreate()</span></a> when
the shared chunk is created. See <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html#GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-D284D6D0-400D-53D2-9A43-05CEE28DFDC4">Example:
Creating a shared chunk</a> to see how the two sets of code connect. </p>
 </li>

<li id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-CB5AE321-CF79-543D-9CA2-DDF1B0B115EC"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-CB5AE321-CF79-543D-9CA2-DDF1B0B115EC"><!-- --></a><p>Ensure that the code
implementing this DFC is still loaded when the DFC runs. As you cannot know
when a chunk will be destroyed, the code should reside in a kernel extension. </p>
 </li>

</ul>
 <p id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-97BF15A2-E74A-51DE-B003-16E1DFF8964E"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-97BF15A2-E74A-51DE-B003-16E1DFF8964E"><!-- --></a><strong>Example: committing
memory</strong> </p>
 <p>This code snippet shows how memory is committed. It is
based on the implementation of the class <samp class="codeph">DBuffers</samp>, which
represents a group of buffers hosted by a single chunk. </p>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9768851E-648B-501D-9AA5-1922EB428EEC"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-9768851E-648B-501D-9AA5-1922EB428EEC"><!-- --></a>/**
  Class representing a group of buffers in the same chunk
*/
class DBuffers
    {
public:
    DBuffers();
    ~DBuffers();
    TInt Create(TInt aBufferSize,TInt aNumBuffers);
public:
    DChunk* iChunk;             /**&lt; The chunk containing the buffers. */
    TLinAddr iChunkKernelAddr;  /**&lt; Address of chunk start in kernel process */
    TUint32 iChunkMapAttr;      /**&lt; MMU mapping attributes used for chunk */
    TInt iBufferSize;           /**&lt; Size of each buffer in bytes */
    TInt iOffsetToFirstBuffer;  /**&lt; Offset within chunk of the first buffer */
    TInt iOffsetBetweenBuffers; /**&lt; Offset in bytes between consecutive buffers */
    };</pre>
 <pre class="codeblock" id="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-CBC59647-DEA3-52AC-B7BD-BF15F29BB0E7"><a name="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10__GUID-CBC59647-DEA3-52AC-B7BD-BF15F29BB0E7"><!-- --></a>/** Constructor */
DBuffers::DBuffers()
    : iChunk(NULL)
    {}

/** Destructor */
DBuffers::~DBuffers()
    {
    if(iChunk) Kern::ChunkClose(iChunk);
    }

/**
  Create the chunk and commit memory for all the buffers.
  @param aBuffserSize Size in bytes of each buffer
  @param aNumBuffers Number of buffers to create
*/
TInt DBuffers::Create(TInt aBufferSize,TInt aNumBuffers)
    {
    // Round buffer size up to MMU page size
    aBufferSize = Kern::RoundToPageSize(aBufferSize);
    iBufferSize = aBufferSize;

    // Size of one MMU page
    TInt pageSize = Kern::RoundToPageSize(1);

    // We will space our buffers with one empty MMU page between each.
    // This helps detect buffer overflows...

    // First buffer starts one MMU page into chunk
    iOffsetToFirstBuffer = pageSize; 

    // Each buffer will be spaced apart by this much
    iOffsetBetweenBuffers = aBufferSize+pageSize;

    // Calculate chunk size
    TUint64 chunkSize = TUint64(iOffsetBetweenBuffers)*aNumBuffers+pageSize;

    // Check size is sensible
    if(chunkSize&gt;(TUint64)KMaxTInt)
        return KErrNoMemory;  // Need more than 2GB of memory!

    // Enter critical section whilst creating objects
    NKern::ThreadEnterCS();

    // Create the chunk
    TChunkCreateInfo info;
    info.iType         = TChunkCreateInfo::ESharedKernelMultiple;
    info.iMaxSize      = (TInt)chunkSize;
    info.iMapAttr      = EMapAttrCachedMax; // Full caching
    info.iOwnsMemory   = ETrue; // Use memory from system's free pool
    info.iDestroyedDfc = NULL;
    TInt r = Kern::ChunkCreate(info, iChunk, iChunkKernelAddr, iChunkMapAttr);
    if(r==KErrNone)
        {
        // Commit memory for each buffer...

        TInt offset = iOffsetToFirstBuffer; // Offset within chunk for first buffer

        // Repeat for each buffer required...
        while(aNumBuffers--)
            {
            // Commit memory at 'offset' within chunk
            r = Kern::ChunkCommit(iChunk,offset,aBufferSize);
            if(r!=KErrNone)
                break;

            // Move 'offset' on to next buffer
            offset += iOffsetBetweenBuffers;
            }

        if(r!=KErrNone)
            {
            // On error, throw away the chunk we have created
            Kern::ChunkClose(iChunk);
            iChunk = NULL; // To indicate that 'this' doesn't have any valid buffers
            }
        }

    // Finished
    NKern::ThreadLeaveCS();
    return r;
    }
</pre>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-DC8D3736-EDCF-54CB-A614-2AAC4664F1CA.html" title="This section describes how device drivers can use the services that the Kernel provides.">Kernel-Side Services</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
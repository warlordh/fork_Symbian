<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-us" xml:lang="en-us">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="cxxFile"/>
<meta name="DC.Title" content="AlwaysOnlineEComInterface.inl"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-3EF0C298-3410-35B9-9FA5-4D1F155BFC86"/>

<title>AlwaysOnlineEComInterface.inl</title>

<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->
<meta name="keywords" content="api"/><link rel="stylesheet" type="text/css" href="cxxref.css"/></head>
<body class="cxxref" id="GUID-3EF0C298-3410-35B9-9FA5-4D1F155BFC86"><a name="GUID-3EF0C298-3410-35B9-9FA5-4D1F155BFC86"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2437088 id2437096 id2366708 id2382304 id2382901 id2382925 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">
<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt;</div>
<h1 class="topictitle1">AlwaysOnlineEComInterface.inl File Reference</h1>
	<div class="nested1" id="GUID-65A1A876-3466-3BBD-AE15-E8B37F245928"><a name="GUID-65A1A876-3466-3BBD-AE15-E8B37F245928"><!-- --></a>
		<h2 class="topictitle2">const TLitC8&lt; sizeof("text, TDesC8* ) { return (TAny*)KErrNotSupported; }inline void CAlwaysOnlineEComInterface::SetStatusQueryObject( MAlwaysOnlineStatusQueryInterface* aStatusQueryObject ) { iStatusQueryObject = aStatusQueryObject; }inline TUid CAlwaysOnlineEComInterface::InstanceUid() { return iDtor_ID_Key; }# 97 "X:/epoc32/include/platform/mw/AlwaysOnlineEComInterface.h" 2# 32 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManager.h" 2# 1 "X:/epoc32/include/platform/mw/AlwaysOnlineStatusQueryInterface.h" 1#define __ALWAYSONLINESTATUSQUERYINTERFACE_H__class MAlwaysOnlineStatusQueryInterface {public: virtual TAny* QueryStatusL( TInt aQuery ) = 0; };# 33 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManager.h" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerDiskSpaceObserver.h" 1#define ALWAYSONLINEDISKSPACEOBSERVER_Hclass CAlwaysOnlineManager;class CAlwaysOnlineDiskSpaceObserver : public CActive { public: static CAlwaysOnlineDiskSpaceObserver* NewL( CAlwaysOnlineManager* aManager, CMsvSession&amp; aSession ); virtual ~CAlwaysOnlineDiskSpaceObserver(); public: void SetLimitAndActivateL(); private: CAlwaysOnlineDiskSpaceObserver( CAlwaysOnlineManager* aManager, CMsvSession&amp; aSession ); private: void RunL(); void DoCancel(); virtual TInt RunError( TInt aError ); private: void HandleLimitChange(); private: CAlwaysOnlineManager* iWatcher; CAlwaysOnlineManager&amp; iManager; CMsvSession&amp; iSession; TUint iNewLimit; TUint iCurrentLimit; }; # 34 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManager.h" 2class CAlwaysOnlineManagerServer;class CAOCenRepControl;class CAlwaysOnlineManager : public CBase, public MAlwaysOnlineStatusQueryInterface, public MConnectionMonitorObserver, public MMsvSessionObserver, public MMsvSingleOpWatcher, public MCenRepNotifyHandlerCallback { public: static CAlwaysOnlineManager* NewL( CAlwaysOnlineManagerServer* aServer ); ~CAlwaysOnlineManager(); void DoStartL(); TAny* QueryStatusL( TInt aQuery ); void HandleOfflineEventL( TInt aEvent ); void EventL( const CConnMonEventBase &amp;aConnMonEvent ); void HandleDiskSpaceEventL( TInt aEvent ); private: void HandleNotifyInt( TUint32 aId, TInt aNewValue ); void HandleNotifyError( TUint32 aId, TInt aError, CCenRepNotifyHandler* aHandler ); void HandleSessionEventL(TMsvSessionEvent aEvent, TAny* aArg1, TAny* , TAny* ); public: void BroadcastClientCommandL( TAlwaysOnlineServerAPICommands aCommand, TDes8&amp; aParameter ); virtual void OpCompleted( CMsvSingleOpWatcher&amp; aOpWatcher, TInt aCompletionCode ); private: CAlwaysOnlineManager(); void ConstructL( CAlwaysOnlineManagerServer* aServer ); void LoadPluginsL(); void StartPluginsL(); void CheckNetworkStatusAndSetObserverL(); void HandleRegistrationStatusL( TInt aStatus ); void BroadcastCommandDirectL( TManagerServerCommands aCommand, TDes8&amp; aParameter ); void InvokeCommandHandlerL( const TManagerServerCommands aCommand, TDes8&amp; aParameter, TInt aIndex ); void QuerySuicideL(); void HandleStartPluginL( const TDes8&amp; aParameter ); void HandleStopPluginL( const TDes8&amp; aParameter ); void StopPluginL( const TUid&amp; aPlugin ); void DisablePlugin( const TUid&amp; aPlugin ); void HandleOpCompletionL( const TDesC8&amp; aProgress ); TBool ParseProgressL( const TDesC8&amp; aProgress, TUid&amp; aUid, TInt&amp; aCommand, TDes8&amp; aResult ); private: TBool iOffline; TInt iNetworkStatus; TBool iPluginsLoaded; CArrayFixFlat&lt;CAlwaysOnlineEComInterface*&gt;* iPluginArray; CArrayFixFlat&lt;TUid&gt;* iDisabledPluginUidsArray; CAlwaysOnlineManagerServer* iServer; CAlwaysOnlineDiskSpaceObserver* iDiskSpaceObserver; RFs iRfs; CMsvSession* iSession; CMsvSingleOpWatcherArray* iOperations; TInt iLastDiskEvent; RConnectionMonitor iConMon; CAOCenRepControl* iCenRepControl; };# 25 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/inc/AlwaysOnlineManagerServer.h" 2const TInt KAlwaysOnlineMajorVersionNumber = 1;const TInt KAlwaysOnlineMinorVersionNumber = 0;const TInt KAlwaysOnlineVersionNumber = 0;class TOAManagerStartupSignaller;const TUint KAOMServerRangeCount = 6;const TInt KAOMServerRanges[KAOMServerRangeCount] = { 0, 3, 1000, 2000, 3000, 4000, };const TUint8 KAOMServerElementsIndex[KAOMServerRangeCount] = { 0, CPolicyServer::ENotSupported, 0, 0, 0, CPolicyServer::ENotSupported, };const CPolicyServer::TPolicyElement KAOMServerElements[] = { {{ (TUint32)( (TUint8) (TUint8)TSecurityPolicy::ETypeC3 | (TUint8) ((TUint8)(int)( ( ECapabilityWriteDeviceData )==ECapability_None ? (__invalid_capability_value(*)[1])(ECapability_None) : (__invalid_capability_value(*)[((TUint)( ECapabilityWriteDeviceData +1)&lt;=(TUint)ECapability_Limit)?1:2])( ECapabilityWriteDeviceData ) )) &lt;&lt; 8 | (TUint8) ((TUint8)(int)( ( ECapability_None )==ECapability_None ? (__invalid_capability_value(*)[1])(ECapability_None) : (__invalid_capability_value(*)[((TUint)( ECapability_None +1)&lt;=(TUint)ECapability_Limit)?1:2])( ECapability_None ) )) &lt;&lt; 16 | (TUint8) ((TUint8)(int)( ( ECapability_None )==ECapability_None ? (__invalid_capability_value(*)[1])(ECapability_None) : (__invalid_capability_value(*)[((TUint)( ECapability_None +1)&lt;=(TUint)ECapability_Limit)?1:2])( ECapability_None ) )) &lt;&lt; 24 ), (TUint32)0xffffffff }, CPolicyServer::EFailClient} }; const CPolicyServer::TPolicy KAOMServerPolicy = { CPolicyServer::EAlwaysPass, KAOMServerRangeCount, KAOMServerRanges, KAOMServerElementsIndex, KAOMServerElements, };class CAlwaysOnlineManagerServer : public CPolicyServer {public: enum {EAlwaysOnlineManagerServerPriority=EPriorityBackground};public: static TInt RunServer(TOAManagerStartupSignaller&amp; aSignaller); static void RunServerL(TOAManagerStartupSignaller&amp; aSignaller); static TInt ServerThreadFunction(TAny* aParameters); static void PanicServer(TAlwaysOnlineManagerPanic aPanic); IMPORT_C static TInt ThreadFunction(TAny* aStarted); IMPORT_C static CAlwaysOnlineManagerServer* NewL(); void ConstructL(); ~CAlwaysOnlineManagerServer(); IMPORT_C void HandleClientCommandL( TAlwaysOnlineServerAPICommands aCommand, TDes8&amp; aParameter ); virtual CSession2* NewSessionL( const TVersion&amp; aVersion, const RMessage2&amp; aMessage ) const;private: CAlwaysOnlineManagerServer( TInt aPriority ); private: CAlwaysOnlineManager* iManager; };# 19 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerServerSession.h" 1#define __ALWAYSONLINEMANAGERSERVERSESSION_H__# 1 "X:/epoc32/include/mw/mtclreg.h" 1#define __MTCLREG_H__ class CObserverRegistry : public CMtmDllRegistry, public MMsvSessionObserver {public: IMPORT_C virtual void HandleSessionEventL(TMsvSessionEvent aEvent, TAny* aArg1, TAny* aArg2, TAny* aArg3); IMPORT_C ~CObserverRegistry();protected: IMPORT_C CObserverRegistry(CMsvSession&amp; aMsvSession,TUid aDllTypeUid,TTimeIntervalMicroSeconds32 aTimeoutMicroSeconds32); IMPORT_C void ConstructL();protected: CMsvSession&amp; iMsvSession; TBool iIsAdded; };class CClientMtmRegistry : public CObserverRegistry {public: IMPORT_C static CClientMtmRegistry* NewL(CMsvSession&amp; aMsvSession, TTimeIntervalMicroSeconds32 aTimeoutMicroSeconds32=TTimeIntervalMicroSeconds32(30000000)); IMPORT_C ~CClientMtmRegistry(); IMPORT_C CBaseMtm* NewMtmL(TUid aMtmTypeUid); protected: CClientMtmRegistry(CMsvSession&amp; aMsvSession,TTimeIntervalMicroSeconds32 aTimeoutMicroSeconds32); void ConstructL(); private: CBaseMtm* DoNewMtmL(const RLibrary&amp; aLib, CRegisteredMtmDll&amp; aReg) const; };# 24 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerServerSession.h" 2class CAlwaysOnlineManagerServer;class CAlwaysOnlineManagerServerSession : public CSession2 {public: static CAlwaysOnlineManagerServerSession* NewL( CAlwaysOnlineManagerServer * aServer ); CAlwaysOnlineManagerServerSession( ); void ConstructL( CAlwaysOnlineManagerServer* aServer ); virtual ~CAlwaysOnlineManagerServerSession(); virtual void ServiceL( const RMessage2 &amp;aMessage ); void DispatchMessageL( const RMessage2 &amp;aMessage ); void PanicClient( const RMessage2&amp; aMessage, TInt aPanic ) const;private: CAlwaysOnlineManagerServer *iAOMServer; };# 20 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerStartupSignaller.h" 1class TOAManagerStartupSignaller {public: inline TOAManagerStartupSignaller(); inline TOAManagerStartupSignaller(TRequestStatus&amp; aStatus);public: inline TPtrC AsCommand() const; TInt GetCommand(); void SignalL();private: TThreadId iThreadId; TRequestStatus* iStatus; };inline TOAManagerStartupSignaller::TOAManagerStartupSignaller() { }inline TOAManagerStartupSignaller::TOAManagerStartupSignaller(TRequestStatus&amp; aStatus): iThreadId(RThread().Id()), iStatus(&amp;aStatus) { aStatus = KRequestPending; }inline TPtrC TOAManagerStartupSignaller::AsCommand() const { return TPtrC( reinterpret_cast&lt;const TText*&gt; this ), sizeof( TOAManagerStartupSignaller ) / sizeof( TText ) ); }# 21 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerLogging.h" 1#define __ALWAYSONLINEMANAGERLOGGING_H__#define KAOMANAGER_LOGGER_DEFINE#define KAOMANAGER_LOGGER_CREATE#define KAOMANAGER_LOGGER_DELETE#define KAOMANAGER_LOGGER_FN1(a) #define KAOMANAGER_LOGGER_FN2(a) #define KAOMANAGER_LOGGER_WRITE(a) #define KAOMANAGER_LOGGER_WRITE_FORMAT(a, b) #define KAOMANAGER_LOGGER_WRITE_FORMAT8(a, b) #define KAOMANAGER_LOGGER_WRITE_TEXT(a)#define KAOMANAGER_LOGGER_WRITE_NUMBER(a)#define KAOMANAGER_LOGGER_WRITE_FORMAT2(a, b)#define KAOMANAGER_LOGGER_WRITE_BUFFER(a) # 22 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2CAlwaysOnlineManagerServer::CAlwaysOnlineManagerServer( TInt aPriority ) : CPolicyServer( aPriority, KAOMServerPolicy ) { ; ; } EXPORT_C CAlwaysOnlineManagerServer* CAlwaysOnlineManagerServer::NewL() { ; CAlwaysOnlineManagerServer* self = new (ELeave) CAlwaysOnlineManagerServer( EAlwaysOnlineManagerServerPriority ); CleanupStack::PushL( self ); self-&gt;ConstructL(); CleanupStack::Pop( self ); self-&gt;StartL( KAlwaysOnlineManagerServerName ); ; return self; }void CAlwaysOnlineManagerServer::ConstructL() { ; iManager = 0 ; TInt err ;{TTrap __t;if (__t.Trap( err )==0){ iManager = CAlwaysOnlineManager::NewL(this) ;TTrap::UnTrap();}}; if( err==KErrNone ) { TInt err2 ;{TTrap __t;if (__t.Trap( err2 )==0){ iManager-&gt;DoStartL() ;TTrap::UnTrap();}}; if(err2!=KErrNone) { ; PanicServer( EAOMServerStartFail ); } } else { ; PanicServer( EAOMServerStartFail ); } ; }CAlwaysOnlineManagerServer::~CAlwaysOnlineManagerServer() { ; delete iManager; ; } EXPORT_C void CAlwaysOnlineManagerServer::HandleClientCommandL( TAlwaysOnlineServerAPICommands aCommand, TDes8&amp; aParameter ) { iManager-&gt; BroadcastClientCommandL</h2>
		<table class="signature"><tr><td>const <a href="GUID-A188447C-9DAA-3963-B6F2-893910450FC7.html">TLitC8</a>&lt; sizeof("text, <a href="GUID-FB97E0A3-352A-316F-97C6-69E4741A8120.html">TDesC8</a>* ) { return (<a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TAny</a>*)<a href="GUID-B36D0060-C3FF-3933-81EF-50790DC89B7E.html">KErrNotSupported</a>; }inline void CAlwaysOnlineEComInterface::SetStatusQueryObject( MAlwaysOnlineStatusQueryInterface* aStatusQueryObject ) { iStatusQueryObject = aStatusQueryObject; }inline <a href="GUID-530281E6-29FC-33F2-BC9B-610FBA389444.html">TUid</a> CAlwaysOnlineEComInterface::InstanceUid() { return iDtor_ID_Key; }# 97 "X:/epoc32/include/platform/mw/AlwaysOnlineEComInterface.h" 2# 32 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManager.h" 2# 1 "X:/epoc32/include/platform/mw/AlwaysOnlineStatusQueryInterface.h" 1#define __ALWAYSONLINESTATUSQUERYINTERFACE_H__class MAlwaysOnlineStatusQueryInterface {public: virtual <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TAny</a>* QueryStatusL( <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aQuery ) = 0; };# 33 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManager.h" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerDiskSpaceObserver.h" 1#define ALWAYSONLINEDISKSPACEOBSERVER_Hclass CAlwaysOnlineManager;class CAlwaysOnlineDiskSpaceObserver : public <a href="GUID-067293BF-B28C-3CEC-92F4-1351A795EA7F.html">CActive</a> { public: static CAlwaysOnlineDiskSpaceObserver* NewL( CAlwaysOnlineManager* aManager, <a href="GUID-2DA04D96-F0AD-3FDC-9E36-1C27D889AF4B.html">CMsvSession</a>&amp; aSession ); virtual ~CAlwaysOnlineDiskSpaceObserver(); public: void SetLimitAndActivateL(); private: CAlwaysOnlineDiskSpaceObserver( CAlwaysOnlineManager* aManager, <a href="GUID-2DA04D96-F0AD-3FDC-9E36-1C27D889AF4B.html">CMsvSession</a>&amp; aSession ); private: void RunL(); void DoCancel(); virtual <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> RunError( <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TInt</a> aError ); private: void HandleLimitChange(); private: CAlwaysOnlineManager* iWatcher; CAlwaysOnlineManager&amp; iManager; <a href="GUID-2DA04D96-F0AD-3FDC-9E36-1C27D889AF4B.html">CMsvSession</a>&amp; iSession; <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a> iNewLimit; <a href="GUID-FC2F2B93-3D18-3BCC-9FD6-6BC6B240B667.html">TUint</a> iCurrentLimit; }; # 34 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManager.h" 2class CAlwaysOnlineManagerServer;class CAOCenRepControl;class CAlwaysOnlineManager : public CBase, public MAlwaysOnlineStatusQueryInterface, public MConnectionMonitorObserver, public MMsvSessionObserver, public MMsvSingleOpWatcher, public MCenRepNotifyHandlerCallback { public: static CAlwaysOnlineManager* NewL( CAlwaysOnlineManagerServer* aServer ); ~CAlwaysOnlineManager(); void DoStartL(); TAny* QueryStatusL( TInt aQuery ); void HandleOfflineEventL( TInt aEvent ); void EventL( const CConnMonEventBase &amp;aConnMonEvent ); void HandleDiskSpaceEventL( TInt aEvent ); private: void HandleNotifyInt( TUint32 aId, TInt aNewValue ); void HandleNotifyError( TUint32 aId, TInt aError, CCenRepNotifyHandler* aHandler ); void HandleSessionEventL(TMsvSessionEvent aEvent, TAny* aArg1, TAny* , TAny* ); public: void BroadcastClientCommandL( TAlwaysOnlineServerAPICommands aCommand, TDes8&amp; aParameter ); virtual void OpCompleted( CMsvSingleOpWatcher&amp; aOpWatcher, TInt aCompletionCode ); private: CAlwaysOnlineManager(); void ConstructL( CAlwaysOnlineManagerServer* aServer ); void LoadPluginsL(); void StartPluginsL(); void CheckNetworkStatusAndSetObserverL(); void HandleRegistrationStatusL( TInt aStatus ); void BroadcastCommandDirectL( TManagerServerCommands aCommand, TDes8&amp; aParameter ); void InvokeCommandHandlerL( const TManagerServerCommands aCommand, TDes8&amp; aParameter, TInt aIndex ); void QuerySuicideL(); void HandleStartPluginL( const TDes8&amp; aParameter ); void HandleStopPluginL( const TDes8&amp; aParameter ); void StopPluginL( const TUid&amp; aPlugin ); void DisablePlugin( const TUid&amp; aPlugin ); void HandleOpCompletionL( const TDesC8&amp; aProgress ); TBool ParseProgressL( const TDesC8&amp; aProgress, TUid&amp; aUid, TInt&amp; aCommand, TDes8&amp; aResult ); private: TBool iOffline; TInt iNetworkStatus; TBool iPluginsLoaded; CArrayFixFlat&lt;CAlwaysOnlineEComInterface*&gt;* iPluginArray; CArrayFixFlat&lt;TUid&gt;* iDisabledPluginUidsArray; CAlwaysOnlineManagerServer* iServer; CAlwaysOnlineDiskSpaceObserver* iDiskSpaceObserver; RFs iRfs; CMsvSession* iSession; CMsvSingleOpWatcherArray* iOperations; TInt iLastDiskEvent; RConnectionMonitor iConMon; CAOCenRepControl* iCenRepControl; };# 25 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/inc/AlwaysOnlineManagerServer.h" 2const TInt KAlwaysOnlineMajorVersionNumber = 1;const TInt KAlwaysOnlineMinorVersionNumber = 0;const TInt KAlwaysOnlineVersionNumber = 0;class TOAManagerStartupSignaller;const TUint KAOMServerRangeCount = 6;const TInt KAOMServerRanges[KAOMServerRangeCount] = { 0, 3, 1000, 2000, 3000, 4000, };const TUint8 KAOMServerElementsIndex[KAOMServerRangeCount] = { 0, CPolicyServer::ENotSupported, 0, 0, 0, CPolicyServer::ENotSupported, };const CPolicyServer::TPolicyElement KAOMServerElements[] = { {{ (TUint32)( (TUint8) (TUint8)TSecurityPolicy::ETypeC3 | (TUint8) ((TUint8)(int)( ( ECapabilityWriteDeviceData )==ECapability_None ? (__invalid_capability_value(*)[1])(ECapability_None) : (__invalid_capability_value(*)[((TUint)( ECapabilityWriteDeviceData +1)&lt;=(TUint)ECapability_Limit)?1:2])( ECapabilityWriteDeviceData ) )) &lt;&lt; 8 | (TUint8) ((TUint8)(int)( ( ECapability_None )==ECapability_None ? (__invalid_capability_value(*)[1])(ECapability_None) : (__invalid_capability_value(*)[((TUint)( ECapability_None +1)&lt;=(TUint)ECapability_Limit)?1:2])( ECapability_None ) )) &lt;&lt; 16 | (TUint8) ((TUint8)(int)( ( ECapability_None )==ECapability_None ? (__invalid_capability_value(*)[1])(ECapability_None) : (__invalid_capability_value(*)[((TUint)( ECapability_None +1)&lt;=(TUint)ECapability_Limit)?1:2])( ECapability_None ) )) &lt;&lt; 24 ), (TUint32)0xffffffff }, CPolicyServer::EFailClient} }; const CPolicyServer::TPolicy KAOMServerPolicy = { CPolicyServer::EAlwaysPass, KAOMServerRangeCount, KAOMServerRanges, KAOMServerElementsIndex, KAOMServerElements, };class CAlwaysOnlineManagerServer : public CPolicyServer {public: enum {EAlwaysOnlineManagerServerPriority=EPriorityBackground};public: static TInt RunServer(TOAManagerStartupSignaller&amp; aSignaller); static void RunServerL(TOAManagerStartupSignaller&amp; aSignaller); static TInt ServerThreadFunction(TAny* aParameters); static void PanicServer(TAlwaysOnlineManagerPanic aPanic); IMPORT_C static TInt ThreadFunction(TAny* aStarted); IMPORT_C static CAlwaysOnlineManagerServer* NewL(); void ConstructL(); ~CAlwaysOnlineManagerServer(); IMPORT_C void HandleClientCommandL( TAlwaysOnlineServerAPICommands aCommand, TDes8&amp; aParameter ); virtual CSession2* NewSessionL( const TVersion&amp; aVersion, const RMessage2&amp; aMessage ) const;private: CAlwaysOnlineManagerServer( TInt aPriority ); private: CAlwaysOnlineManager* iManager; };# 19 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerServerSession.h" 1#define __ALWAYSONLINEMANAGERSERVERSESSION_H__# 1 "X:/epoc32/include/mw/mtclreg.h" 1#define __MTCLREG_H__ class CObserverRegistry : public CMtmDllRegistry, public MMsvSessionObserver {public: IMPORT_C virtual void HandleSessionEventL(TMsvSessionEvent aEvent, TAny* aArg1, TAny* aArg2, TAny* aArg3); IMPORT_C ~CObserverRegistry();protected: IMPORT_C CObserverRegistry(CMsvSession&amp; aMsvSession,TUid aDllTypeUid,TTimeIntervalMicroSeconds32 aTimeoutMicroSeconds32); IMPORT_C void ConstructL();protected: CMsvSession&amp; iMsvSession; TBool iIsAdded; };class CClientMtmRegistry : public CObserverRegistry {public: IMPORT_C static CClientMtmRegistry* NewL(CMsvSession&amp; aMsvSession, TTimeIntervalMicroSeconds32 aTimeoutMicroSeconds32=TTimeIntervalMicroSeconds32(30000000)); IMPORT_C ~CClientMtmRegistry(); IMPORT_C CBaseMtm* NewMtmL(TUid aMtmTypeUid); protected: CClientMtmRegistry(CMsvSession&amp; aMsvSession,TTimeIntervalMicroSeconds32 aTimeoutMicroSeconds32); void ConstructL(); private: CBaseMtm* DoNewMtmL(const RLibrary&amp; aLib, CRegisteredMtmDll&amp; aReg) const; };# 24 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerServerSession.h" 2class CAlwaysOnlineManagerServer;class CAlwaysOnlineManagerServerSession : public CSession2 {public: static CAlwaysOnlineManagerServerSession* NewL( CAlwaysOnlineManagerServer * aServer ); CAlwaysOnlineManagerServerSession( ); void ConstructL( CAlwaysOnlineManagerServer* aServer ); virtual ~CAlwaysOnlineManagerServerSession(); virtual void ServiceL( const RMessage2 &amp;aMessage ); void DispatchMessageL( const RMessage2 &amp;aMessage ); void PanicClient( const RMessage2&amp; aMessage, TInt aPanic ) const;private: CAlwaysOnlineManagerServer *iAOMServer; };# 20 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerStartupSignaller.h" 1class TOAManagerStartupSignaller {public: inline TOAManagerStartupSignaller(); inline TOAManagerStartupSignaller(TRequestStatus&amp; aStatus);public: inline TPtrC AsCommand() const; TInt GetCommand(); void SignalL();private: TThreadId iThreadId; TRequestStatus* iStatus; };inline TOAManagerStartupSignaller::TOAManagerStartupSignaller() { }inline TOAManagerStartupSignaller::TOAManagerStartupSignaller(TRequestStatus&amp; aStatus): iThreadId(RThread().Id()), iStatus(&amp;aStatus) { aStatus = KRequestPending; }inline TPtrC TOAManagerStartupSignaller::AsCommand() const { return TPtrC( reinterpret_cast&lt;const TText*&gt; this ), sizeof( TOAManagerStartupSignaller ) / sizeof( TText ) ); }# 21 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2# 1 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/inc/AlwaysOnlineManagerLogging.h" 1#define __ALWAYSONLINEMANAGERLOGGING_H__#define KAOMANAGER_LOGGER_DEFINE#define KAOMANAGER_LOGGER_CREATE#define KAOMANAGER_LOGGER_DELETE#define KAOMANAGER_LOGGER_FN1(a) #define KAOMANAGER_LOGGER_FN2(a) #define KAOMANAGER_LOGGER_WRITE(a) #define KAOMANAGER_LOGGER_WRITE_FORMAT(a, b) #define KAOMANAGER_LOGGER_WRITE_FORMAT8(a, b) #define KAOMANAGER_LOGGER_WRITE_TEXT(a)#define KAOMANAGER_LOGGER_WRITE_NUMBER(a)#define KAOMANAGER_LOGGER_WRITE_FORMAT2(a, b)#define KAOMANAGER_LOGGER_WRITE_BUFFER(a) # 22 "X:/sf/mw/messagingmw/messagingfw/alwaysonline/AlwaysOnlineManager/src/AlwaysOnlineManagerServer.cpp" 2CAlwaysOnlineManagerServer::CAlwaysOnlineManagerServer( TInt aPriority ) : CPolicyServer( aPriority, KAOMServerPolicy ) { ; ; } EXPORT_C CAlwaysOnlineManagerServer* CAlwaysOnlineManagerServer::NewL() { ; CAlwaysOnlineManagerServer* self = new (ELeave) CAlwaysOnlineManagerServer( EAlwaysOnlineManagerServerPriority ); CleanupStack::PushL( self ); self-&gt;ConstructL(); CleanupStack::Pop( self ); self-&gt;StartL( KAlwaysOnlineManagerServerName ); ; return self; }void CAlwaysOnlineManagerServer::ConstructL() { ; iManager = 0 ; TInt err ;{TTrap __t;if (__t.Trap( err )==0){ iManager = CAlwaysOnlineManager::NewL(this) ;TTrap::UnTrap();}}; if( err==KErrNone ) { TInt err2 ;{TTrap __t;if (__t.Trap( err2 )==0){ iManager-&gt;DoStartL() ;TTrap::UnTrap();}}; if(err2!=KErrNone) { ; PanicServer( EAOMServerStartFail ); } } else { ; PanicServer( EAOMServerStartFail ); } ; }CAlwaysOnlineManagerServer::~CAlwaysOnlineManagerServer() { ; delete iManager; ; } EXPORT_C void CAlwaysOnlineManagerServer::HandleClientCommandL( TAlwaysOnlineServerAPICommands aCommand, TDes8&amp; aParameter ) { iManager-&gt;</td><td>BroadcastClientCommandL</td><td>[static]</td></tr></table><div class="section"></div>

	</div>

	
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Render Stage Interfaces"/>
<meta name="abstract" content="This topic builds on the Render Stages Overview and provides an introduction to the main render stage interfaces."/>
<meta name="description" content="This topic builds on the Render Stages Overview and provides an introduction to the main render stage interfaces."/>
<meta name="DC.Relation" scheme="URI" content="GUID-3A2785D4-6185-50C3-8D7E-5D94CD2B7C98.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-975CBC70-81E6-5FA2-80CE-88DD2ABE9595.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-57A777A3-5D67-5CBB-B224-B7AD422A451B.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-0C4B86B5-530A-5839-86C1-46E7ABE281E0.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-5D81D4E2-BE8B-58CE-A745-4F044DE2FB5F.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-3A2785D4-6185-50C3-8D7E-5D94CD2B7C98.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-309B01B6-F74A-5EF0-B225-702BF8814847.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-2B6D3A9D-1481-5587-A954-48CE7EC311EE.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-98EA7E2B-4AC6-55AE-985F-B5EE1E0A79E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-41802B91-26B3-5F3C-AE04-B6954F3804B7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-D76C7759-739D-5C98-B718-7297687FE630.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Render Stage Interfaces</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2384330 id2384499 id2384574 id2384967 id2384982 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-975CBC70-81E6-5FA2-80CE-88DD2ABE9595.html">Graphics Guide</a> &gt; <a href="GUID-57A777A3-5D67-5CBB-B224-B7AD422A451B.html" title="The Windowing collection contains two components—the Window Server, which manages the use of the screen by applications, and the Window Server Plugins component.">Windowing Collection</a> &gt; <a href="GUID-0C4B86B5-530A-5839-86C1-46E7ABE281E0.html" title="The Window Server component manages the use of the screen by applications and handles key and pointer events.">Window Server Component</a> &gt; <a href="GUID-5D81D4E2-BE8B-58CE-A745-4F044DE2FB5F.html" title="This section describes the generic Window Server plug-in framework and is mainly aimed at system integrators, UI platform providers and device and hardware manufacturers.">Window Server Plug-in Framework</a> &gt; <a href="GUID-3A2785D4-6185-50C3-8D7E-5D94CD2B7C98.html" title="This section provides information about the render stage framework in ScreenPlay. This framework enables device creators to change the lower layers of the rendering pipeline without changing the Window Server code.">Render Stages</a> &gt; </div>
<h1 class="topictitle1">Render
Stage Interfaces</h1>
<div><p>This topic builds on the Render Stages Overview and provides an
introduction to the main render stage interfaces. </p>

<p> <strong>Variant</strong>: <a href="GUID-D93978BE-11A3-5CE3-B110-1DEAA5AD566C.html" title="This topic provides an introduction to ScreenPlay and its architecture. ScreenPlay is a new graphics architecture, introduced in Symbian^3 (S^3). ScreenPlay enables device creators to take advantage of improved software performance, hardware acceleration and third party graphics engines. ScreenPlay is sometimes known as the New Graphics Architecture (NGA).">ScreenPlay</a>. <strong>Target
audience</strong>: Device creators. </p>

<p>The <a href="GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87.html" title="Render stages are ROM-based plug-ins to the Window Server render stage framework. They can be chained to form a rendering pipeline, which takes the draw operations that are produced by the Window Server and ultimately passes them to the UI surface. Render stages can selectively filter, modify, or redirect the draw operation stream, as required—for example, to perform transition effects (TFX).">Render Stages
Overview</a> introduced some of the interfaces that render stages implement.
Here we will look at those in more detail, along with some of the other interfaces. </p>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-48000875-54A6-4563-8FC0-86320EA69D2C"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-48000875-54A6-4563-8FC0-86320EA69D2C"><!-- --></a><h2 class="sectiontitle">MWsObjectProvider</h2> <p> <a href="GUID-A47A4139-70FD-3F76-B51E-0452A0F6A76F.html"><span class="apiname">MWsObjectProvider</span></a> is
a Window Server plug-in framework interface, which provides a mechanism through
which classes can offer extension interfaces. Render stages and most of the
related classes implement this interface. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-06DE55A6-6346-4F78-8F4A-320F15ADB822"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-06DE55A6-6346-4F78-8F4A-320F15ADB822"><!-- --></a><h2 class="sectiontitle">CWsRenderStage</h2> <p> <a href="GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A.html"><span class="apiname">CWsRenderStage</span></a> is
an abstract class that all render stages must derive from. It has two pure
virtual functions: <samp class="codeph">Begin()</samp> and <samp class="codeph">End()</samp>, which
must be implemented in the concrete class. </p>
 <p>The Window Server's output
to the render stage pipeline is not a continuous stream, but instead consists
of batches of drawing operations. When client drawing or server-side animations
require a screen update, the <a href="GUID-22093E74-EFE7-5642-93DE-1573E18F7C08.html" title="This topic provides a brief introduction to the Window Server's rendering loop, which takes place in two stages, known as the upper loop and the lower loop.">Window
Server rendering loop</a> schedules a redraw. When this redraw occurs,
a batch of drawing operations is produced to perform the updates. </p>
 <p>The
Window Server calls <a href="GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A.html#GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A__GUID-75503F6F-91DA-3392-8CD5-34FFF9095D30"><span class="apiname">CWsRenderStage::Begin()</span></a> at the beginning
of a batch of draw operations. This gives the render stages an opportunity
to perform any preparation. Similarly the Window Server calls <a href="GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A.html#GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A__GUID-0EBA06BF-D17F-3485-85B6-F4B855A48B62"><span class="apiname">CWsRenderStage::End()</span></a> at
the end of the batch, which provides the render stages with the opportunity
to perform any tidying up. </p>
 <p>For example, a flicker buffer render stage
might use the <samp class="codeph">Begin()</samp> call as a signal to clear its off-screen
buffer, and the <samp class="codeph">End()</samp> call as a signal to perform the blit
of the accumulated updates to the next render stage. The final render stage
might use the <samp class="codeph">End()</samp> call as the signal to submit a surface
update to the composition engine. </p>
 <p>Render stages perform all rendering
operations between the <samp class="codeph">Begin()</samp> and <samp class="codeph">End()</samp> calls.
The Window Server calls the <a href="GUID-44844998-D8BF-3F2F-9BA2-FB9BB497F8C0.html"><span class="apiname">MWsGraphicsContext</span></a> functions
only between the <samp class="codeph">Begin()</samp> and <samp class="codeph">End()</samp> calls.
The render stage could <samp class="codeph">ASSERT</samp> that these functions are not
called at other times and ignore them if they are or take some other action
as appropriate. However, render stages can safely call composition context
functions outside the <samp class="codeph">Begin()</samp> and <samp class="codeph">End()</samp> calls.
In addition, the <a href="GUID-B1E048A2-D5E8-3E7F-A6AC-6B8F3ED3067C.html"><span class="apiname">MWsScreenDevice</span></a> functions may be called
at any time. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-B189C7EB-AD1F-51C6-91F1-8EBD49D8F69D"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-B189C7EB-AD1F-51C6-91F1-8EBD49D8F69D"><!-- --></a><h2 class="sectiontitle">MWsGraphicsContext</h2> <p> <a href="GUID-44844998-D8BF-3F2F-9BA2-FB9BB497F8C0.html"><span class="apiname">MWsGraphicsContext</span></a> is
the interface for GDI-like drawing. The Window Server requests this interface
from the first render stage in the chain using the object provider mechanism.
This is a mandatory interface, which means that a render stage must not return
null when it receives an object provider request for this interface. However,
providing an implementation is not mandatory. For example, a logging render
stage might simply delegate to the next render stage instead of returning
its own implementation of this interface. </p>
 <p>The member functions correspond
to functions in <a href="GUID-4A501086-7EFF-376D-8901-6D9B2EB4EFF2.html"><span class="apiname">CFbsBitGc</span></a> (such as <samp class="codeph">DrawText()</samp> and <samp class="codeph">BitBlt()</samp>)
but without functions that are not suitable for hardware acceleration (such
as read-modify-write functions like <samp class="codeph">SetFaded()</samp>). </p>
 <p>The
final render stage in the chain typically provides an implementation of <a href="GUID-44844998-D8BF-3F2F-9BA2-FB9BB497F8C0.html"><span class="apiname">MWsGraphicsContext</span></a> in
terms of a concrete rendering context—for example, by translating into BitGDI
or OpenVG calls. </p>
 <p>If <strong>extended bitmaps</strong> are supported on the device,
the implementation of the functions that receive a <a href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html"><span class="apiname">CFbsBitmap</span></a> as
an argument can check whether it is the handle to an extended bitmap. If it
is, the render stage can process the proprietary data within the bitmap. You
can get access to the proprietary data by using <a href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html#GUID-683A1D42-2764-3EB7-BD19-9E12559199AB__GUID-2AB943ED-7DBE-3FDA-82AF-317F152EDB03"><span class="apiname">CFbsBitmap::DataAddress()</span></a>.
Here is a simple example: </p>
 <pre class="codeblock" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-390E236B-7EB1-5A90-B1F5-A0190403FF27"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-390E236B-7EB1-5A90-B1F5-A0190403FF27"><!-- --></a>// bmp points to a bitmap to be drawn.
TUid type = bmp-&gt;ExtendedBitmapType();
    
if (type==KUidMyProprietaryFormat)
    {    
    bmp-&gt;BeginDataAccess();
    const TUint32* data = bmp-&gt;DataAddress();
    TInt dataSize = bmp-&gt;DataSize();
    ProcessMyData(data, dataSize);
    bmp-&gt;EndDataAccess(ETrue);
    }
</pre>
 <p>For some data formats, particularly those that contain vector
data, such as SVG, this approach has advantages compared to letting the extended
bitmap rasterizer DLL process the proprietary data. For example, the extended
bitmap rasterizer DLL rasterizes the proprietary data into a pixel buffer,
which is then blitted to the screen. In contrast the render stage can insert
the drawing commands directly into the drawing command stream without the
use of intermediate pixel buffers. In addition, unlike the extended bitmap
rasterizer DLL, the render stage does not need to rasterize the image to a
higher resolution in order to scale it down. The use of the render stage to
process the proprietary data can therefore potentially save memory and improve
performance, depending on the data format. </p>
 <p>Although the Symbian Foundation
does not currently provide extended bitmap functionality in the main render
stages, it does provide a test extended bitmap render stage. You can use this
as an example when you implement your own extended bitmap functionality. </p>
 <p>For
more information, see <a href="GUID-D76C7759-739D-5C98-B718-7297687FE630.html" title="The Font and Bitmap Server provides a framework for device creators to add support for their own types of bitmap compression. Bitmaps that use compression formats that are provided by device creators are known as extended bitmaps.">Extended
Bitmaps</a>. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-490A69C0-E8F0-4767-965E-798C5953A8D9"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-490A69C0-E8F0-4767-965E-798C5953A8D9"><!-- --></a><h2 class="sectiontitle">MWsScene </h2> <p> <a href="GUID-43972649-4BDE-3D93-8658-35F224915A43.html"><span class="apiname">MWsScene</span></a> is the composition
context interface for use with <a href="GUID-8FE41C9A-8171-58A2-A808-17B81E79B11F.html" title="This section describes the OpenWF Composition (OpenWF-C) components. OpenWF-C is an open standard for layered graphics composition developed by the Khronos Group.">OpenWF
composition</a>. It is a mandatory interface. However, like <a href="GUID-44844998-D8BF-3F2F-9BA2-FB9BB497F8C0.html"><span class="apiname">MWsGraphicsContext</span></a>,
some render stages might simply delegate to the next render stage rather than
providing their own implementations. The final render stage in the chain typically
provides an implementation of <a href="GUID-43972649-4BDE-3D93-8658-35F224915A43.html"><span class="apiname">MWsScene</span></a> in terms of OpenWF-C. </p>
 <p>The <a href="GUID-43972649-4BDE-3D93-8658-35F224915A43.html"><span class="apiname">MWsScene</span></a> interface
defines the composition context for a particular screen (or an off-screen
buffer representing the screen) in terms of a collection of rectangular regions.
These are called <a href="GUID-41802B91-26B3-5F3C-AE04-B6954F3804B7.html" title="This topic provides an introduction to the concept of scene elements within the context of graphics composition. Scene elements are sometimes referred to as layers.">scene
elements</a> or simply <strong>elements</strong>. Each one is represented by the <a href="GUID-48B10795-1C8F-3D21-9637-6C7A02C95C75.html"><span class="apiname">MWsElement</span></a> interface.
The <a href="GUID-43972649-4BDE-3D93-8658-35F224915A43.html"><span class="apiname">MWsScene</span></a> interface manages the relative ordinal positions
of the elements and uses the elements to track external surfaces and their
place in the composition scene. Render stages can manipulate element metadata
in order to perform transition effects and use the hardware-accelerated composition
facilities provided by OpenWF-C to perform transition effects (such as slide,
zoom and fade). </p>
 <p>Some of the key functions are: </p>
 <ul>
<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-8265EB9F-14A5-54C5-B3EB-3925964121A5"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-8265EB9F-14A5-54C5-B3EB-3925964121A5"><!-- --></a><p> <samp class="codeph">CreateSceneElementL()</samp>.
Creates a new element for use in the scene. After creation, an element is
available to the caller but <samp class="codeph">InsertSceneElement()</samp> must be
called to actually insert it into the pending scene. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-8736EC49-0C43-58AB-B9F1-397D2B7D6486"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-8736EC49-0C43-58AB-B9F1-397D2B7D6486"><!-- --></a><p> <samp class="codeph">InsertSceneElement()</samp>.
Inserts an element into the scene. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-9016ACE1-E1BC-5126-A7D8-8A564CF96865"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-9016ACE1-E1BC-5126-A7D8-8A564CF96865"><!-- --></a><p> <samp class="codeph">RemoveSceneElement()</samp>.
Removes an element from the scene. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-832568D5-4DCD-59CF-9982-2C6584AFC2B9"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-832568D5-4DCD-59CF-9982-2C6584AFC2B9"><!-- --></a><p> <samp class="codeph">DestroySceneElement()</samp>.
Destroys an element and removes its resources from the scene. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-BA1D1346-EE28-5179-BBC9-300618162607"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-BA1D1346-EE28-5179-BBC9-300618162607"><!-- --></a><p> <samp class="codeph">ComposePendingScene()</samp>.
Renders the pending scene to an off-screen target. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-AF8EFE14-B829-5B4B-998E-3CF161F027C1"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-AF8EFE14-B829-5B4B-998E-3CF161F027C1"><!-- --></a><p> <samp class="codeph"> RegisterSurface()</samp>.
Marks a surface as potentially in use beyond its lifetime within the scene.
There are two typical use cases—one is where the contents of the surface (for
example, a video frame) must be maintained when users switch to another application
that hides the surface so that it is no longer part of the scene. This means
that users can have a seamless experience when they switch back to the video.
The other use case is where the content of a surface needs to be populated
before it is attached to a window and therefore added to the scene. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-CE8BB038-0B65-5C78-B457-F7B532471826"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-CE8BB038-0B65-5C78-B457-F7B532471826"><!-- --></a><p> <samp class="codeph">UnregisterSurface()</samp>.
Marks the surface as no longer in use beyond its inclusion in the scene. </p>
 </li>

</ul>
 <p>Any updates to the scene introduced by the render stage (such as
adding a new element) are pending until the Window Server calls <a href="GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A.html#GUID-B89CEF40-0139-3E6F-803D-F74E2BCB029A__GUID-0EBA06BF-D17F-3485-85B6-F4B855A48B62"><span class="apiname">CWsRenderStage::End()</span></a> to
commit the scene. </p>
 </div>


<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-2924C0EE-222B-4A23-830B-DD31A985C13F"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-2924C0EE-222B-4A23-830B-DD31A985C13F"><!-- --></a><h2 class="sectiontitle">MWsElement</h2> <p> <a href="GUID-48B10795-1C8F-3D21-9637-6C7A02C95C75.html"><span class="apiname">MWsElement</span></a> is a
mandatory interface for managing scene elements when <a href="GUID-8FE41C9A-8171-58A2-A808-17B81E79B11F.html" title="This section describes the OpenWF Composition (OpenWF-C) components. OpenWF-C is an open standard for layered graphics composition developed by the Khronos Group.">OpenWF
composition</a> is in use. This interface is obtained by using <a href="GUID-43972649-4BDE-3D93-8658-35F224915A43.html#GUID-43972649-4BDE-3D93-8658-35F224915A43__GUID-B776F464-8AAE-32C4-A0FF-026D8E553B7D"><span class="apiname">MWsScene::CreateSceneElementL()</span></a> rather
than the object provider mechanism. </p>
 <p>The <a href="GUID-48B10795-1C8F-3D21-9637-6C7A02C95C75.html"><span class="apiname">MWsElement</span></a> interface
provides a way of associating metadata with an image source. From the render
stage's point of view, the image source is a surface that is connected to
the element—whereas OpenWF-C has the concept of image sources that are created
from native streams. Because the <a href="GUID-83510B5B-9725-5272-BF51-23A089178DAC.html" title="The OpenWF Support component provides a Symbian-specific implementation of platform-specific elements of the OpenWF-C specification and abstracts communication between the OpenWF-C Engine and other Symbian graphics components.">OpenWF-C
Support component</a> implements native streams in terms of Symbian surfaces,
the render stage can ignore this distinction and simply cast the address of
the <a href="GUID-11F60AEB-003B-3E8D-BDB9-D97F698627DF.html"><span class="apiname">TSurfaceId</span></a> to the OpenWF-C native stream type (<a href="GUID-DF6DF530-EC4E-32D4-9CC8-536F3F2BE83E.html"><span class="apiname">WFCNativeStreamType</span></a>). </p>
 <p>The
element metadata includes the following: </p>
 <ul>
<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-BD2BD787-B90D-5E00-A533-7401CB4A7CB4"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-BD2BD787-B90D-5E00-A533-7401CB4A7CB4"><!-- --></a><p>Source rectangle—the
region within the surface from which pixels are taken. This enables the surface
to be cropped and is equivalent to the surface viewport described in <a href="GUID-495EA1C8-E95F-54AE-B4D1-0F463003C2D7.html" title="This topic provides an introduction to displaying an external surface on a window. The surface is then known as a background surface. This feature is available in ScreenPlay only.">External Surfaces Overview</a>. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-CFD9C7F9-78EA-5719-A5F1-DD2D78ECFEE8"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-CFD9C7F9-78EA-5719-A5F1-DD2D78ECFEE8"><!-- --></a><p>Destination rectangle—the
target rectangle in the composition output to which the pixels are rendered.
This is equivalent to the extent. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-9EE4ECD3-7274-553B-8123-250EE3E7751A"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-9EE4ECD3-7274-553B-8123-250EE3E7751A"><!-- --></a><p>Global alpha—a global
alpha value for use in blending the surface into the composition output. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-1FA2DF2A-2FBC-551B-B4D9-6D6711F46D39"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-1FA2DF2A-2FBC-551B-B4D9-6D6711F46D39"><!-- --></a><p>Source rotation—the
number of quadrant angles by which the contents of the surface are rotated. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-3830D1D3-8687-5C7A-B886-F1B0CED6BF26"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-3830D1D3-8687-5C7A-B886-F1B0CED6BF26"><!-- --></a><p>Source flipping—a Boolean
value that indicates whether the contents of the surface are flipped. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-7535C9D7-314C-5EF6-8D50-226DC5F2DE33"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-7535C9D7-314C-5EF6-8D50-226DC5F2DE33"><!-- --></a><p>Target renderer flags—these
provide information to the rendering subsystem (for example, the OpenWF-C
engine), such as whether the renderer should blend based on the global alpha
value or the alpha channel in the surface itself. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-8B50BD6E-5F9A-5690-99CC-73AE8D129B52"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-8B50BD6E-5F9A-5690-99CC-73AE8D129B52"><!-- --></a><p>Render stage flags—these
provide information to the render stages, such as whether the UI surface is
always on top. </p>
 </li>

</ul>
 </div>


<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-4A3F1B94-9EFE-47EE-A060-FAB8E92D3F3C"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-4A3F1B94-9EFE-47EE-A060-FAB8E92D3F3C"><!-- --></a><h2 class="sectiontitle">MWsScreenDevice</h2> <p> <a href="GUID-B1E048A2-D5E8-3E7F-A6AC-6B8F3ED3067C.html"><span class="apiname">MWsScreenDevice</span></a> is
the interface for managing the screen. It provides functions for controlling
rotation and fetching data from the screen such as a screen snapshot. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-3558E65B-F8C9-4A63-B22E-41B7E2ECB21D"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-3558E65B-F8C9-4A63-B22E-41B7E2ECB21D"><!-- --></a><h2 class="sectiontitle">MWsTextCursor</h2> <p> <a href="GUID-F43CBB9C-238B-33C5-B872-AAE0104F047E.html"><span class="apiname">MWsTextCursor</span></a> is
an interface that enables render stages to implement a text cursor to represent
the flashing bar or rectangle that represents the current position when editing
text. </p>
 <p>Prior to the introduction of ScreenPlay text cursors were drawn
using XOR drawing because it provides high contrast against the background.
Render stages can implement this interface using the same approach but it
is generally inefficient on hardware-accelerated platforms. Therefore another
approach, such as a drop shadow or sprite, might be preferable. </p>
 <p>The
preferred solution is that clients use <a href="GUID-643DDA78-C7A7-386D-AB3F-8710141DDDA9.html#GUID-643DDA78-C7A7-386D-AB3F-8710141DDDA9__GUID-684910B9-CCEA-3798-BE23-967820BBF363"><span class="apiname">RWsSession::SetCustomTextCursor()</span></a> to
replace the text cursor with a sprite. This means that user themes can use
a sprite that matches the text—for example, a white sprite with white text
and a black sprite with black text. If a client does this, the render stage’s <a href="GUID-F43CBB9C-238B-33C5-B872-AAE0104F047E.html"><span class="apiname">MWsTextCursor</span></a> API
is not used when drawing text cursors for that client. Instead, the text cursor
sprite is drawn using GDI draw operations through the <a href="GUID-44844998-D8BF-3F2F-9BA2-FB9BB497F8C0.html"><span class="apiname">MWsGraphicsContext</span></a> interface. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-6D6482E9-7AD7-46A1-AFFB-B98B6BAB1973"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-6D6482E9-7AD7-46A1-AFFB-B98B6BAB1973"><!-- --></a><h2 class="sectiontitle">MWsFader</h2> <p> <a href="GUID-1CF41CFD-27C8-39D7-A615-18CE765436DE.html"><span class="apiname">MWsFader</span></a> is the interface
for providing fading capabilities. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-EDE3C8A9-1EBB-4B8C-A483-1F469A19CCB5"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-EDE3C8A9-1EBB-4B8C-A483-1F469A19CCB5"><!-- --></a><h2 class="sectiontitle">MWsWindowTreeObserver</h2> <p> <a href="GUID-028CC583-AC32-3D60-943A-A80F84E05DD2.html"><span class="apiname">MWsWindowTreeObserver</span></a> is
an optional interface that enables a render stage to create a replica of the
window tree, known as the <strong>visuals tree</strong>. The Window Server uses this
interface to tell the render stage about the window tree structure and changes
to window tree nodes. Note that this interface considers animations and sprites
to be nodes in the window tree. </p>
 <p>See the <a href="GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87.html#GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87__GUID-5D81D1A7-26A0-5461-9AC5-3EF359D283CB">Advanced
Use Case</a> section of the <a href="GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87.html" title="Render stages are ROM-based plug-ins to the Window Server render stage framework. They can be chained to form a rendering pipeline, which takes the draw operations that are produced by the Window Server and ultimately passes them to the UI surface. Render stages can selectively filter, modify, or redirect the draw operation stream, as required—for example, to perform transition effects (TFX).">Render
Stages Overview</a> for more information. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-7536F610-F9F7-5E17-82D8-623D774DC091"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-7536F610-F9F7-5E17-82D8-623D774DC091"><!-- --></a><h2 class="sectiontitle">MWsDrawAnnotationObserver</h2> <p> <a href="GUID-21240143-D578-3114-9836-F765F70A987C.html"><span class="apiname">MWsDrawAnnotationObserver</span></a> is
an optional interface that enables render stages to associate a batch of drawing
operations with a specific window or node in the visuals tree. TFX render
stages generally need to implement this interface. </p>
 <p>If the render stage
implements the <a href="GUID-028CC583-AC32-3D60-943A-A80F84E05DD2.html"><span class="apiname">MWsWindowTreeObserver</span></a> interface, implementing
the <samp class="codeph">MWsDrawAnnotationObserver</samp> interface enables the render
stage to know which node in the visuals tree each batch of drawing operations
belongs to. This means that the render stage can associate the batch with
the correct window, sprite or other element in the visuals tree and manage
it efficiently. </p>
 <p>If the render stage does <strong>not</strong> implement the <samp class="codeph">MWsWindowTreeObserver</samp> interface,
the <samp class="codeph">MWsDrawAnnotationObserver</samp> interface still provides the
window tree node pointers for each batch of drawing operations. There are
two different approaches this type of render stage can take: </p>
 <ul>
<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-3248DECC-4F1E-5504-AC00-751D33D032A5"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-3248DECC-4F1E-5504-AC00-751D33D032A5"><!-- --></a><p>The render stage can
treat the window tree node pointers as unique identifiers for the windows.
This approach is typically used when the Window Server's default <a href="GUID-22093E74-EFE7-5642-93DE-1573E18F7C08.html" title="This topic provides a brief introduction to the Window Server's rendering loop, which takes place in two stages, known as the upper loop and the lower loop.">dirty-rectangle
rendering mode</a> is in use. In this mode the Window Server sends the
batches of drawing operations to the first render stage in back to front z-order.
(That is, the drawing operations for the windows in the background come before
the drawing operations for the windows at the front.) Using the unique identifier
and the z-order, the render stage can identify new windows that are at the
top and slide them on or perform some other transition effect. </p>
 <p>This
approach is suitable when the render stage always performs the same transition
effect. For example, the render stage slides on all new windows that are at
the front. </p>
 </li>

<li id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-F21BC536-DE1C-585C-B183-AF499AC31FC6"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-F21BC536-DE1C-585C-B183-AF499AC31FC6"><!-- --></a><p>The other approach is
suitable when the render stage applies transition effects to specific windows;
for example, windows that belong to a media player application. In this scenario,
the client communicates the handles of those windows to the render stage.
The render stage uses the <samp class="codeph">MWsDrawAnnotationObserver</samp> to retrieve
the handles of the windows to which the drawing operations relate. The render
stage compares these handles with those communicated by the client and for
which the transition effects are required. When a handle matches, the render
stage performs the transition effect. When the handle does not match, the
render stage passes the drawing operations straight through to the next render
stage in the chain. </p>
 <p>The following code snippet shows how to retrieve
a window's handle from the <a href="GUID-7837D4F3-4BF4-344B-B987-6789060553B3.html"><span class="apiname">MWsWindowTreeNode</span></a> object returned
by the <samp class="codeph">MWsDrawAnnotationObserver</samp> functions: </p>
 <pre class="codeblock" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-156D0D65-0746-5FED-BB8F-8188D6B2C7F7"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-156D0D65-0746-5FED-BB8F-8188D6B2C7F7"><!-- --></a>windowID = aWindowTreeNode.Window-&gt;Handle();</pre>
 <p> <em>Note</em>:
Communication of the window handle from the client to the render stage is
beyond the scope of this documentation. </p>
 </li>

</ul>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-6EC4AF69-61E8-475A-9D87-3E0B5634E173"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-6EC4AF69-61E8-475A-9D87-3E0B5634E173"><!-- --></a><h2 class="sectiontitle">MWsWindowVisibilityNotifier</h2> <p> <a href="GUID-FF3EE463-E775-3948-B1EB-66135E24A623.html"><span class="apiname">MWsWindowVisibilityNotifier</span></a> is
an optional interface that enables a render stage to communicate changes in
the visibility of windows and other nodes in the window tree to the Window
Server. A render stage that works in <a href="GUID-22093E74-EFE7-5642-93DE-1573E18F7C08.html" title="This topic provides a brief introduction to the Window Server's rendering loop, which takes place in two stages, known as the upper loop and the lower loop.">change-tracking
rendering mode</a> must implement this interface. </p>
 <p>When the Window
Server is in its default dirty-rectangle tracking mode, it tracks which windows
are visible and sends visibility-changed events to clients, Content Rendering
Plug-ins (CRPs) and animation plug-ins. This enables these clients to know
when their windows are visible and therefore need to draw or animate, and
when they are obscured and do not need to draw or animate. This means that
CPU cycles are not wasted producing animations when they are not visible and
ensures that animations run when they are visible. </p>
 <p>When the Window
Server is in change-tracking mode, it does not track the visible regions and
tracking of visible regions is delegated to the render stage. At the minimum,
the render stage must set the visible region to be the whole window or none
of it. </p>
 <p>The Window Server implements the <a href="GUID-9CF4DEE1-57D8-3F57-93B2-6EB701262AD7.html"><span class="apiname">MWsWindowVisibilityObserver</span></a> interface
through which it responds to visibility change notifications sent by the render
stage. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-5CDE2713-4CBD-4B35-A10F-A599B7C4EC55"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-5CDE2713-4CBD-4B35-A10F-A599B7C4EC55"><!-- --></a><h2 class="sectiontitle">MWsDisplayControl</h2> <p> <a href="GUID-415B5416-A6DD-3471-8800-C76C48DA59DA.html"><span class="apiname">MWsDisplayControl</span></a> is
the interface for controlling the display configuration. See <a href="GUID-2B6D3A9D-1481-5587-A954-48CE7EC311EE.html" title="ScreenPlay has a new approach to display resolution control to support externally connected displays, such as TV-out. It involves the render stages plus a number of other components in the Graphics package, including the Window Server and the composition engine. The render stages are able to monitor and modify display control attributes, and to scale and position the application extent within the full UI area. In addition, they can optionally implement a display policy, which determines the UI to composition mapping policy.">Render
Stage Display Control and Mapping</a> for more information. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-D35742C7-B61F-417F-9EA0-9B07633FBBBC"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-D35742C7-B61F-417F-9EA0-9B07633FBBBC"><!-- --></a><h2 class="sectiontitle">MWsDisplayMapping</h2> <p> <a href="GUID-ED4CAB66-F8F8-3AF2-A388-F28406A3B104.html"><span class="apiname">MWsDisplayMapping</span></a> is
the interface for mapping between coordinate spaces. See <a href="GUID-2B6D3A9D-1481-5587-A954-48CE7EC311EE.html" title="ScreenPlay has a new approach to display resolution control to support externally connected displays, such as TV-out. It involves the render stages plus a number of other components in the Graphics package, including the Window Server and the composition engine. The render stages are able to monitor and modify display control attributes, and to scale and position the application extent within the full UI area. In addition, they can optionally implement a display policy, which determines the UI to composition mapping policy.">Render
Stage Display Control and Mapping</a> for more information. </p>
 </div>

<div class="section" id="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-95E80D04-3A9F-4657-AB94-1F3AF5048AB2"><a name="GUID-11BC2AAA-FDB8-5600-8488-F27A9552E336__GUID-95E80D04-3A9F-4657-AB94-1F3AF5048AB2"><!-- --></a><h2 class="sectiontitle">MWsDisplayPolicy</h2> <p> <a href="GUID-0A31CF3E-25A9-36BA-80D6-8FBD18419506.html"><span class="apiname">MWsDisplayPolicy</span></a> is
an optional interface, which if implemented, determines the UI to composition
mapping policy. See <a href="GUID-2B6D3A9D-1481-5587-A954-48CE7EC311EE.html" title="ScreenPlay has a new approach to display resolution control to support externally connected displays, such as TV-out. It involves the render stages plus a number of other components in the Graphics package, including the Window Server and the composition engine. The render stages are able to monitor and modify display control attributes, and to scale and position the application extent within the full UI area. In addition, they can optionally implement a display policy, which determines the UI to composition mapping policy.">Render
Stage Display Control and Mapping</a> for more information. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-3A2785D4-6185-50C3-8D7E-5D94CD2B7C98.html" title="This section provides information about the render stage framework in ScreenPlay. This framework enables device creators to change the lower layers of the rendering pipeline without changing the Window Server code.">Render Stages</a></div>
</div>
<div class="relinfo relconcepts"><strong>Related concepts</strong><br/>
<div><a href="GUID-2E8929E6-9555-51D2-B41D-6F1D05A4DB87.html" title="Render stages are ROM-based plug-ins to the Window Server render stage framework. They can be chained to form a rendering pipeline, which takes the draw operations that are produced by the Window Server and ultimately passes them to the UI surface. Render stages can selectively filter, modify, or redirect the draw operation stream, as required—for example, to perform transition effects (TFX).">Render Stage
Overview</a></div>
<div><a href="GUID-309B01B6-F74A-5EF0-B225-702BF8814847.html" title="This topic provides examples of how a transition effect (TFX) render stage can perform simple transitions in the ScreenPlay variant. Note that the APIs are different in the non-ScreenPlay variant.">TFX Render
Stage                 Examples</a></div>
<div><a href="GUID-2B6D3A9D-1481-5587-A954-48CE7EC311EE.html" title="ScreenPlay has a new approach to display resolution control to support externally connected displays, such as TV-out. It involves the render stages plus a number of other components in the Graphics package, including the Window Server and the composition engine. The render stages are able to monitor and modify display control attributes, and to scale and position the application extent within the full UI area. In addition, they can optionally implement a display policy, which determines the UI to composition mapping policy.">Display 
               Control and Mapping</a></div>
<div><a href="GUID-98EA7E2B-4AC6-55AE-985F-B5EE1E0A79E7.html" title="This topic provides information about creating and configuring a render stage plug-in. It applies to ScreenPlay and is aimed at device creators and system integrators who want to create a customized rendering pipeline.">Creating
a Render Stage                 Plug-in</a></div>
<div><a href="GUID-41802B91-26B3-5F3C-AE04-B6954F3804B7.html" title="This topic provides an introduction to the concept of scene elements within the context of graphics composition. Scene elements are sometimes referred to as layers.">Scene Elements</a></div>
<div><a href="GUID-D76C7759-739D-5C98-B718-7297687FE630.html" title="The Font and Bitmap Server provides a framework for device creators to add support for their own types of bitmap compression. Bitmaps that use compression formats that are provided by device creators are known as extended bitmaps.">Extended
Bitmaps</a></div>
</div>
</div>   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
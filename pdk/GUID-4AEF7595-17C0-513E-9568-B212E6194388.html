<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Record operation"/>
<meta name="abstract" content="Describes the operation of the Sound Driver for sound recording."/>
<meta name="description" content="Describes the operation of the Sound Driver for sound recording."/>
<meta name="DC.Relation" scheme="URI" content="GUID-8DC12024-7599-52E8-BCF1-D9D765EC7B9B.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-52371DAB-A231-558C-B3E6-220DAAEE566B.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-669C77A3-89BA-5321-ABB1-4356A5FE478C.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-6D75968E-53CF-5436-8390-54CA12BCFDE9.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-8DC12024-7599-52E8-BCF1-D9D765EC7B9B.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-4AEF7595-17C0-513E-9568-B212E6194388"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Record operation</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-4AEF7595-17C0-513E-9568-B212E6194388"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2400778 id2402156 id2402170 id2402191 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-52371DAB-A231-558C-B3E6-220DAAEE566B.html" title="Provides software components that implement the interface between Symbian platform and peripherals.">Logical Device Drivers</a> &gt; <a href="GUID-669C77A3-89BA-5321-ABB1-4356A5FE478C.html" title="Describes how to create a port of the sound driver for your phone hardware.">Sound Driver</a> &gt; <a href="GUID-6D75968E-53CF-5436-8390-54CA12BCFDE9.html" title="Describes the technology, architecture, and behaviour of the Sound Driver.">Concepts</a> &gt; <a href="GUID-8DC12024-7599-52E8-BCF1-D9D765EC7B9B.html" title="Describes the behaviour of the Sound Driver for and record operations.">Dynamic Behaviour</a> &gt; </div>
<h1 class="topictitle1">Record
operation</h1>
<div><p>Describes the operation of the Sound Driver for sound recording.</p>

<div class="section" id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-0722033C-4BC0-45D0-B980-C1FC680BBF70"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-0722033C-4BC0-45D0-B980-C1FC680BBF70"><!-- --></a><h2 class="sectiontitle">Client functions</h2> <p>Many aspects regarding the way
that the Sound Driver recording operates are similar to the way it handles
playback. One difference is how the memory location in the <a href="GUID-51514A4B-0220-557B-9F7A-FB110CEFEF10.html" title="A shared chunk is a mechanism that kernel-side code uses to share memory buffers safely with user-side code.">Shared
Chunks</a> for the transfer is determined. In play requests, the client
specifies the source location in the chunk for the transfer having arranged
for the data to be loaded there prior to the request. For record requests,
the client just requests a buffers worth of record data and allows the driver
to decide which buffer to use for the request. </p>
 <p>The driver commences
recording when the client issues the first <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-D96D7433-6CB5-3368-8B51-C19731C474AF"><span class="apiname">RSoundSc::RecordData()</span></a> request.
However, unlike playback operation, once recording has commenced, the driver
continues to record data into its available record buffers until it is told
to stop. To stop the driver capturing record data, the client must either
issue <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-16C40CF6-C84D-3901-8527-EA66842E0AAC"><span class="apiname">RSoundSc::Pause()</span></a> to temporarily suspend recording, <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-4B53ED55-EC95-35B3-B9D6-A24EF70D81F9"><span class="apiname">RSoundSc::CancelRecordData()</span></a> to
terminate record operation, or close the driver channel altogether. </p>
 <p>The
client specifies the number and size of the record buffers available to the
driver within the shared chunk by calling either <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-1978D84C-6E2A-39C0-AF5F-17C85E5B25B4"><span class="apiname">RSoundSc::SetBufferChunkCreate()</span></a>,
to create a buffer, or <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-46096E39-A530-3644-91F0-0B97AC3C6580"><span class="apiname">RSoundSc::SetBufferChunkOpen()</span></a> to
open an existing buffer. </p>
 <p>When the driver starts recording, all the
buffers in the shared chunk are empty, and the driver can use all of these
available buffers. They are filled one by one, and if the client is slow to
request the recorded data, then once the driver has filled all of the available
empty buffers, it is forced to discard the earliest one filled and re-use
this to continue recording data. </p>
 <p>Each time the client requests a buffers
worth of recorded data with <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-D96D7433-6CB5-3368-8B51-C19731C474AF"><span class="apiname">RSoundSc::RecordData()</span></a>, it
is given the earliest one filled. This buffer is now said to be in-use and
unavailable to the driver for capturing. This buffer remains in-use until
it is freed by the client with a call of <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-26F7C97B-D06A-32BE-90B3-2E6918BF3F4D"><span class="apiname">RSoundSc::ReleaseBuffer()</span></a>. </p>
 <p>When
buffers are in use by the client the number of buffers available to the driver
for capture is reduced. If the client is slow to release buffers and the number
of available buffers falls to two then further <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-D96D7433-6CB5-3368-8B51-C19731C474AF"><span class="apiname">RSoundSc::RecordData()</span></a> requests
fail with <samp class="codeph">KErrInUse</samp> until the client has freed some buffers.
The driver always needs a working set of at least two buffers in order to
achieve uninterrupted data capture. The driver always has a current buffer
which is actively being filled and another queued in advance. If the client
fails to take buffers at full speed then they are discarded by the driver. </p>
<div class="p"><div class="note"><span class="notetitle">Note:</span>  The
driver does not slow down if it runs out of empty buffers. </div>
</div>
 <p><strong>Buffers</strong> </p>
 <p>The driver maintains three buffer lists: </p>
 <ul>
<li id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-D0B884B5-3687-5CB9-B732-1B028F0008A8"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-D0B884B5-3687-5CB9-B732-1B028F0008A8"><!-- --></a><p>free list </p>
 </li>

<li id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-3A3FAAA7-72C2-5A35-9F4D-3824966D3D52"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-3A3FAAA7-72C2-5A35-9F4D-3824966D3D52"><!-- --></a><p>completed list </p>
 </li>

<li id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-E571D299-99C5-51D1-832E-55A88533B365"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-E571D299-99C5-51D1-832E-55A88533B365"><!-- --></a><p>in-use list. </p>
 </li>

</ul>
 <p>A record buffer can only exist in one of these lists at any time.
The free list contains buffers that are empty and not in use by the client.
Once a buffer has been filled with record data it is moved into the completed
buffer list. Here the buffer remains until it is passed back to the client
in response to a record request. When a client is using the buffer it is deemed
as in-use and is moved to the <em>in-use</em> list. Each time the client successfully
calls <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-26F7C97B-D06A-32BE-90B3-2E6918BF3F4D"><span class="apiname">RSoundSc::ReleaseBuffer()</span></a> to free up a buffer then
the driver moves this from the in-use list to the free list. </p>
 <p>The driver
also maintains two record buffers which are excluded from any of the three
lists. </p>
 <ul>
<li id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-3EB509DB-F35F-51E7-AAD9-8A25EEDAE604"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-3EB509DB-F35F-51E7-AAD9-8A25EEDAE604"><!-- --></a><p>the current buffer,
the one actively being filled with record data </p>
 </li>

<li id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-E109F4E5-998D-5B19-AE82-A913BBF4CED3"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-E109F4E5-998D-5B19-AE82-A913BBF4CED3"><!-- --></a><p>the next buffer which
becomes the active buffer once the current buffer is filled </p>
 </li>

</ul>
 <p>During recording there may be DMA requests pending for both the current
buffer and the next buffers. </p>
 <div class="fignone" id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-FBF47E94-8334-55D3-9AC0-FDAF1F9960B1"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-FBF47E94-8334-55D3-9AC0-FDAF1F9960B1"><!-- --></a><span class="figcap">Figure 1.                  The record buffer cycle               </span>. <span class="figdesc"><p>The numbers one to five show the buffer cycle under normal operation,
while the letters A to C show error induced operation. </p>
 </span>


<img src="GUID-1A92047A-3C1D-5B4C-949B-98D770F5F530_d0e412692_href.png"/>
</div>
 <p>When recording commences, the driver removes two buffers from the
free list making one the current buffer and the other the next buffer (4 and
5). </p>
 <p>When the current buffer is set as filled, the LDD normally adds
this to the completed list (1). If a record error has occurred while recording
to this buffer and it is only partially filled, or even empty then the buffer
is still added to the completed list, as the client needs to be informed of
the error (1). The only exception is in handling record pause, where a record
buffer ends up being completed with no error and with no data added. In this
case the buffer is added straight into the free list (A). </p>
 <p>Having added
the current buffer to one of these lists, the driver moves the next buffer
to the current buffer (5) and then obtains a new next buffer (4). In normal
operation this comes from the free list but if the client is slow, this list
may be empty and the buffer is taken from the completed list (B). This is
a buffer overflow situation which is reported to the client as a response
to its next <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-D96D7433-6CB5-3368-8B51-C19731C474AF"><span class="apiname">RSoundSc::RecordData()</span></a> request as <samp class="codeph">KErrOverFlow</samp>. </p>
 <p>Whenever
a buffer is filled, the driver checks if there is a record request pending
(1). Similarly, when the driver processes a new record request it checks if
a filled buffer is already available. In either case, if a request can be
completed to the client then the earliest buffer completed is returned. If
this buffer was filled successfully then it added to the in-use list (2).
However, if an error occurred whilst filling the buffer then it is returned
straight to the free list instead (C). </p>
 <p>Each time the client successfully
calls <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-26F7C97B-D06A-32BE-90B3-2E6918BF3F4D"><span class="apiname">RSoundSc::ReleaseBuffer()</span></a> to free up a buffer then
the driver moves this from the in-use list to the free list (3). </p>
 </div>

<div class="section" id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-548515F6-403D-4C99-AAA3-027C7D303C73"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-548515F6-403D-4C99-AAA3-027C7D303C73"><!-- --></a><h2 class="sectiontitle">Audio recording</h2> <p><strong>RecordData()</strong> </p>
 <p>If
the driver is not already recording data then the first <a href="GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3.html#GUID-B0118EDD-2B08-353E-BE92-2DC75E5622B3__GUID-D96D7433-6CB5-3368-8B51-C19731C474AF"><span class="apiname">RSoundSc::RecordData()</span></a> request
is handled in the context of the driver DFC thread, as access to the audio
hardware is required to enable record operation. However, for efficiency,
subsequent record requests from the client are handled entirely in the context
of the calling thread, as access to the audio hardware is not required to
handle the request. The driver only has to check whether there is a filled
record buffer already available. If there is then the driver completes the
request straight away. If not, the driver saves the details of the request
until a filled buffer does become available. </p>
 <p>Returning to the case
of a record request where the driver is not already in the process of recording
data, the LDD first checks whether the client has specified or supplied a
shared chunk to the driver channel and has set the audio configuration and
record level. If the buffer configuration has not been specified then the
driver cannot proceed and returns <samp class="codeph">KErrNotReady</samp>. If the audio
configuration or record level has not been specified then the LDD applies
default settings to the audio hardware device for each instead by calling
the functions <a href="GUID-E1C67F8D-1A83-36B3-A451-22F496A659C6.html#GUID-E1C67F8D-1A83-36B3-A451-22F496A659C6__GUID-23CEDA72-E161-30C4-B8D7-DBDCBC5B9C63"><span class="apiname">DSoundSc::SetConfig()</span></a> and <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-D893A29B-1A4B-35AF-876B-84D74B7E783C"><span class="apiname">DSoundScPdd::SetVolume()</span></a> on
the PDD. </p>
 <p><strong>StartTransfer()</strong> </p>
 <p>Depending
on the mapping attributes of the shared chunk, the LDD may now need to purge
the region of the record chunk concerned. Next the LDD calls <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-54D3CC19-0C00-3FFA-BD1A-62618D36EB20"><span class="apiname">DSoundScPdd::StartTransfer()</span></a> on
the PDD to allow it to prepare the audio hardware device for record data transfer. </p>
 <p><strong>TransferData()</strong> </p>
 <p>The LDD may need to break down the record buffer
into memory fragments. These specify a physically contiguous region and are
manageable by the PDD as a single transfer. The LDD queues as many transfer
fragments of the current buffer on the PDD as it can accept with a call to <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-8C79D09B-317A-3D8E-B9C2-474812F17529"><span class="apiname">DSoundScPdd::TransferData()</span></a> for
each fragment. If all fragments from the current buffer are accepted by the
PDD then the LDD tries to queue fragments from the next buffer. As with playback,
to support uninterrupted transfer of audio data the PDD must be able to accept
multiple fragments simultaneously. As long as the LDD has transfer fragments
still to queue, it continues to call <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-8C79D09B-317A-3D8E-B9C2-474812F17529"><span class="apiname">DSoundScPdd::TransferData()</span></a> until
the PDD signals that it has temporarily reached its capacity by returning <samp class="codeph">KErrNotReady</samp>. </p>
 <p><strong>RecordCallBack()</strong> </p>
 <p>Each time the PDD completes the transfer
of a fragment from a record buffer, it must signal this event back to the
LDD by calling the function <a href="GUID-5807543D-A30F-3EB9-8F28-91A623B0D484.html#GUID-5807543D-A30F-3EB9-8F28-91A623B0D484__GUID-9112E399-DC3C-334F-BE16-B5F42216F903"><span class="apiname">DSoundScLdd::RecordCallBack()</span></a>.
This must always be called in the context of the driver DFC thread. In executing <a href="GUID-5807543D-A30F-3EB9-8F28-91A623B0D484.html#GUID-5807543D-A30F-3EB9-8F28-91A623B0D484__GUID-434E378F-0C48-39D9-8FB8-9831A1F704C0"><span class="apiname">DSoundScLdd::RecordCallback()</span></a>,
the LDD checks whether the entire transfer for the current buffer is now complete.
If so, depending on the mapping attributes of the shared chunk, the LDD may
need to purge the region of the record client. The LDD attempts to queue further
fragments on the PDD, by calling <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-8C79D09B-317A-3D8E-B9C2-474812F17529"><span class="apiname">DSoundScPdd::TransferData()</span></a>,
which should now have the capability to accept more transfers. So, the PDD
should be written to handle calls to <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-8C79D09B-317A-3D8E-B9C2-474812F17529"><span class="apiname">DSoundScPdd::TransferData()</span></a> within
its call back to <a href="GUID-5807543D-A30F-3EB9-8F28-91A623B0D484.html#GUID-5807543D-A30F-3EB9-8F28-91A623B0D484__GUID-434E378F-0C48-39D9-8FB8-9831A1F704C0"><span class="apiname">DSoundScLdd::RecordCallback()</span></a>. </p>
 </div>

<div class="section" id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-7B5CF9A4-8527-4C76-96CD-C03F861AF3BF"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-7B5CF9A4-8527-4C76-96CD-C03F861AF3BF"><!-- --></a><h2 class="sectiontitle">Pause and resume audio recording</h2> <p>The client can
temporarily halt the progress of audio record at any time by issuing <a href="GUID-5807543D-A30F-3EB9-8F28-91A623B0D484.html#GUID-5807543D-A30F-3EB9-8F28-91A623B0D484__GUID-D912620F-9C51-3AFC-8A59-31AF9455AC4A"><span class="apiname">DSoundScLdd::Pause()</span></a>.
To configure the audio hardware device to halt recording, the LDD calls <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-0608766F-2645-3E28-B804-BD4B953DB5FF"><span class="apiname">DSoundScPdd::PauseTransfer()</span></a> on
the PDD. This time, any active transfer should be aborted by the PDD. If a
recording is halted the PDD must signal this event with a single call of the
LDD function <a href="GUID-3731902C-9C34-3FAE-8F82-9F9493C2C2E7.html#GUID-3731902C-9C34-3FAE-8F82-9F9493C2C2E7__GUID-73F74080-6219-3D9A-BA56-735A17A9ABA0"><span class="apiname">DSOundScLdd::RecordCallback()</span></a>, which reports
back any partial data already received. In this case, if transfer is resumed
later, the LDD issues a new <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-8C79D09B-317A-3D8E-B9C2-474812F17529"><span class="apiname">DSoundScPdd::TransferData()</span></a> request
to commence data transfer after calling <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-C692BF61-FA3D-3B85-BCC6-1248C9C7D9BF"><span class="apiname">DSoundScPdd::ResumeTransfer()</span></a>.
As access to the hardware is required in both cases, pause and resume are
handled in the context of the driver DFC thread. </p>
 </div>

<div class="section" id="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-BA951968-290F-4DA5-842A-2004664B1139"><a name="GUID-4AEF7595-17C0-513E-9568-B212E6194388__GUID-BA951968-290F-4DA5-842A-2004664B1139"><!-- --></a><h2 class="sectiontitle">Error handling during recording</h2> <p>If the PDD reports
an error when setting up the audio hardware device for recording then the
LDD immediately completes the first record request back to the client returning
the error value as the result. It will not restart record data transfer unless
it receives a further record request from the client. </p>
 <p>If the PDD reports
an error when commencing the transfer of a record fragment or as the result
of the transfer of a record fragment, then the LDD ceases transfer to that
record buffer and instead reports the error back to the client. The error
is returned in response to the record request which corresponds with that
buffer. </p>
 <p>Unexpected errors from the PDD are returned to the LDD via
the functions <a href="GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424.html#GUID-61CC68CB-A01D-3CA0-93D9-F3717ABD6424__GUID-8C79D09B-317A-3D8E-B9C2-474812F17529"><span class="apiname">DSoundScPdd::TransferData()</span></a> and <a href="GUID-5807543D-A30F-3EB9-8F28-91A623B0D484.html#GUID-5807543D-A30F-3EB9-8F28-91A623B0D484__GUID-434E378F-0C48-39D9-8FB8-9831A1F704C0"><span class="apiname">DSoundScLdd::RecordCallback()</span></a>. </p>
 <p>The
LDD does not try to cancel the transfer of other fragments for the same buffer
that are already queued on the PDD, but it ignores their outcome. However,
the LDD does try to carry on with the transfer to other available record buffers. </p>
 </div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-8DC12024-7599-52E8-BCF1-D9D765EC7B9B.html" title="Describes the behaviour of the Sound Driver for and record operations.">Dynamic Behaviour</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
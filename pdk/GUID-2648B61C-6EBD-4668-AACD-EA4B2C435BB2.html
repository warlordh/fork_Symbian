<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="copyright" content="(C) Copyright 2010"/>
<meta name="DC.rights.owner" content="(C) Copyright 2010"/>
<meta name="DC.Type" content="concept"/>
<meta name="DC.Title" content="Message Handling"/>
<meta name="abstract" content="This document describes message queues and message handling."/>
<meta name="description" content="This document describes message queues and message handling."/>
<meta name="DC.Relation" scheme="URI" content="GUID-CFE0A4EB-845C-43B6-A732-AA155AFD99D6.html"/>
<meta name="DC.Relation" scheme="URI" content="index.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-C22974D8-CFB9-4A83-BE58-CCC97EA8DF13.html"/>
<meta name="DC.Relation" scheme="URI" content="GUID-CFE0A4EB-845C-43B6-A732-AA155AFD99D6.html"/>
<meta name="DC.Format" content="XHTML"/>
<meta name="DC.Identifier" content="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2"/>
<meta name="DC.Language" content="en"/>
<link rel="stylesheet" type="text/css" href="commonltr.css"/>
<title>Message Handling</title>

     
<link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->



     <link rel="stylesheet" type="text/css" href="nokiacxxref.css"/></head>
<body id="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2"><a name="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2"><!-- --></a>


<?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
<div id="sdl_container">
   <div id="leftMenu">  
 <div id="expandcontractdiv">
    <a id="collapseTree" href="javascript:tree.collapseAll()">Collapse all</a>
    <a id="index" href="index.html">Symbian^3 Product Developer Library</a>        
</div>
     <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">&#160;</div>
     <script type="text/javascript">
	var currentIconMode = 0; window.name="id2563754 id2387835 id2387995 id2388032 id2388267 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
     
</div>

<div id="sdl_content">


<div class="breadcrumb"><a href="index.html" title="Symbian^3 Product Developer Library">Symbian^3 Product Developer Library</a> &gt; <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">Symbian Guide</a> &gt; <a href="GUID-C14B2552-43A7-4499-ABFE-1725128DA6EF.html" title="Kernel and Hardware Services performs the fundamental operating system tasks of managing access to device resources.">Kernel and Hardware Services Guide</a> &gt; <a href="GUID-F78B7BF9-5FDD-4EF8-A921-71CCBB830A99.html" title="The device driver framework and how to implement a device driver.">Device Driver Guide</a> &gt; <a href="GUID-C22974D8-CFB9-4A83-BE58-CCC97EA8DF13.html" title="This set of documents explains how to write a device driver.">Device Driver Writing Guide</a> &gt; <a href="GUID-CFE0A4EB-845C-43B6-A732-AA155AFD99D6.html" title="This document introduces user requests and synchronisation methods used by device drivers.">User Requests and Synchronisation</a> &gt; </div>
<h1 class="topictitle1">Message
Handling</h1>
<div><p>This document describes message queues and message handling.</p>

<div class="section" id="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-AE9A6778-85AE-4D1D-BF61-EE06339549D9"><a name="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-AE9A6778-85AE-4D1D-BF61-EE06339549D9"><!-- --></a><h2 class="sectiontitle">Message queues</h2> <p>The
request handling kernel side DFC is managed by a message queue object of the <a href="GUID-F10B7D2F-D546-3997-A020-37A0D894F1CD.html"><span class="apiname">TMessageQueue</span></a> type.
The message queue consists of a DFC and a doubly linked list of received messages.
The messages are represented by <a href="GUID-D43CB8FA-C212-3B56-AD16-9F1D69DA7551.html"><span class="apiname">TThreadMessage</span></a> objects
and are owned by each user thread. Requests are queued as message objects
on the message queue. </p>
 <p>The driver framework requires that the driver
sets a DFC queue to use with the message queue. This is done by calling <a href="GUID-A3CC1D95-4681-3349-A67C-F113A614041D.html#GUID-A3CC1D95-4681-3349-A67C-F113A614041D__GUID-EB160A2E-39A9-3739-ABDE-C91E2A28D26D"><span class="apiname">DLogicalChannel::SetDfcQ()</span></a>.
The message queue must also be enabled to receive incoming messages by calling <a href="GUID-382DD935-E9D7-3E00-88B2-B28A89CAD4FB.html#GUID-382DD935-E9D7-3E00-88B2-B28A89CAD4FB__GUID-EF06556E-9EC6-3D1C-AEE9-0CDDF6B42A24"><span class="apiname">TMessageQue::Receive()</span></a>. </p>
 <pre class="codeblock" id="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-A995A927-113D-5CB6-B813-DF88DC02D0C1"><a name="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-A995A927-113D-5CB6-B813-DF88DC02D0C1"><!-- --></a>// Logical Channel Second stage constructor
TInt DExDriverLogicalChannel::DoCreate(TInt /*aUnit*/, const TDesC8*
        /*anInfo*/, const TVersion&amp; aVer)
    {
    ...
    // Set up the DFC queue for this driver. Here, the DFC 
    // queue is created by the PDD dedicated for this driver.
    SetDfcQ(Pdd()-&gt;DfcQ());

    // Start receiving the incoming requests on the message queue
    iMsgQ.Receive();
    ...
    }</pre>
 <p>The Kernel provides a standard DFC queue, which runs
on a dedicated kernel thread called <samp class="codeph">DFCThread0</samp>, for general
use by drivers. However, it is recommended that the driver creates its own
DFC thread to process its requests. The following example shows how a PDD
can implement the <samp class="codeph">DfcQ()</samp> function to return a newly created
DFC thread: </p>
 <pre class="codeblock" id="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-4753E5B1-8B8F-5589-8547-C94B48B7D66A"><a name="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-4753E5B1-8B8F-5589-8547-C94B48B7D66A"><!-- --></a>// DfcQ - Creates a DFC queue dedicated for the tutorial driver
TDynamicDfcQue* DExUartPhysicalChannelH4::DfcQ()
    {
    // Create a DFC queue dedicated to the driver with a specified 
    // priority
    TInt r = Kern::DynamicDfcQCreate(pDfcQ,KExUartDfcPriority,
    KExUartDfcName);
    if (r!=KErrNone)
        {
        // DfcQ failed, return NULL
        return NULL;
        }
    return iDfcQueue;
    }</pre>
 <p>The DFC thread that is created for the driver must be
destroyed after use. To do this, the driver can create an Exit or Kill DFC
request and queue it to the thread to be destroyed in the logical channel
destructor. This exit DFC function cancels any other requests pending using <a href="GUID-A14562A5-3E91-3113-AB3C-71DBEA9D58EB.html#GUID-A14562A5-3E91-3113-AB3C-71DBEA9D58EB__GUID-9851B90B-8D05-3C86-B083-44C4564AC140"><span class="apiname">TDfc::Cancel()</span></a> and
calls <a href="GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D.html#GUID-C6946ECB-775F-3EC2-A56F-78F25B9FBE3D__GUID-808B3622-BDC4-376D-96E9-16281BA28AF8"><span class="apiname">Kern::Exit()</span></a> to terminate the thread. </p>
 <p>The <a href="GUID-D9111A26-FAA3-3D8E-AB41-5B1263FABB6A.html"><span class="apiname">TDynamicDfcQue</span></a> has
a destroy method that can be run on the channel destructor. The destroy method
destroys the DFC queue, kills the DFC thread and deletes the <a href="GUID-D9111A26-FAA3-3D8E-AB41-5B1263FABB6A.html"><span class="apiname">TDynamicDfcQue</span></a> object
itself. This avoids the possibilities of memory leaks in the DFC. </p>
</div>

<div class="section" id="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-2463763E-1838-4D7D-80F2-D77420B49D09"><a name="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-2463763E-1838-4D7D-80F2-D77420B49D09"><!-- --></a><h2 class="sectiontitle">Message handling</h2> <p>All
synchronous and asynchronous requests are passed to the <a href="GUID-621F4531-996F-33BB-8081-4B2067CC262A.html"><span class="apiname">HandleMsg()</span></a> function
by the framework, with the message as an argument. A driver should implement
the function to identify the message type and handle the messages accordingly. </p>
 <p>The
client thread is blocked until the message is completed, as the request uses
the thread's message object. If the client thread was left free, it would
corrupt the message if another request was issued. </p>
 <p>When the driver
has completed handling the message, it notifies the framework by calling <a href="GUID-D43CB8FA-C212-3B56-AD16-9F1D69DA7551.html#GUID-D43CB8FA-C212-3B56-AD16-9F1D69DA7551__GUID-20CFC972-7C07-36D8-BAC8-BB63AA4612B6"><span class="apiname">TThreadMessage::Complete()</span></a>.
The client thread is then unblocked, and can either block on the thread semaphore
or issue further requests before blocking. </p>
 <p>For synchronous requests,
the message is not completed until the request itself is complete, and the
driver calls the <samp class="codeph">TThreadMessage::Complete()</samp> function after
the actual completion of the request. However, for asynchronous requests,
the message is completed after the driver has accepted the request, but not
necessarily after the actual completion of the request, which can happen later.
This means that the driver calls <samp class="codeph">TThreadMessage::Complete()</samp> as
soon as it has received the message and initiated the required processing
to complete the request. </p>
 <pre class="codeblock" id="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-C178DFFA-2321-5396-AED6-5244BBF98388"><a name="GUID-2648B61C-6EBD-4668-AACD-EA4B2C435BB2__GUID-C178DFFA-2321-5396-AED6-5244BBF98388"><!-- --></a>void DExDriverLogicalChannel::HandleMsg(TMessageBase* aMsg)
    {            
    TThreadMessage&amp; m = *(TThreadMessage*)aMsg;        
    // obtain the function id value to determine the request nature
    TInt id = m.iValue;        
    ...
    if (id&gt;=0)    // Synchronous messages
        {
        // call synchronous message handler function, DoControl()    
        TInt r = DoControl(id,m.Ptr0(),m.Ptr1());
        m.Complete(r,ETrue);
        return;
        }    
    }</pre>
</div>

</div>
<div>
<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong> <a href="GUID-CFE0A4EB-845C-43B6-A732-AA155AFD99D6.html" title="This document introduces user requests and synchronisation methods used by device drivers.">User Requests and Synchronisation</a></div>
</div>
</div>
   
<p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
</div>
</div>
<?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>

</body>
</html>
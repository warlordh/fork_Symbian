<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="copyright" content="(C) Copyright 2010" />
  <meta name="DC.rights.owner" content="(C) Copyright 2010" />
  <meta name="DC.Type" content="concept" />
  <meta name="DC.Title" content="Symbian-Specific Behavior" />
  <meta name="abstract" content="This topic provides information about the points that the EGL specification explicitly states are platform-specific. This information is aimed at both users and implementers of EGL on the Symbian platform." />
  <meta name="description" content="This topic provides information about the points that the EGL specification explicitly states are platform-specific. This information is aimed at both users and implementers of EGL on the Symbian platform." />
  <meta name="DC.Relation" scheme="URI" content="GUID-D252E75C-C8CA-5C51-8DA3-95B937A1295C.html" />
  <meta name="DC.Relation" scheme="URI" content="index.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-975CBC70-81E6-5FA2-80CE-88DD2ABE9595.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-8C6D4350-A38D-57A1-8C8D-C777EA7E8A3E.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-D252E75C-C8CA-5C51-8DA3-95B937A1295C.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-D252E75C-C8CA-5C51-8DA3-95B937A1295C.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-DC8BFEF5-DA50-52DA-8CE2-5729A4A005F6.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-53707903-9A88-409B-80F8-FDF7EF47ACBF.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-484B51EC-2209-5492-8E9C-9D792AB0DF35.html" />
  <meta name="DC.Format" content="XHTML" />
  <meta name="DC.Identifier" content="GUID-894AB487-C127-532D-852B-37CB0DEA1440" />
  <meta name="DC.Language" content="en" />
  <link rel="stylesheet" type="text/css" href="commonltr.css" />
  <title>
   Symbian-Specific Behavior
  </title>
  <link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->
  <link rel="stylesheet" type="text/css" href="nokiacxxref.css" />
 </head>
 <body id="GUID-894AB487-C127-532D-852B-37CB0DEA1440">
  <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440">
   <!-- -->
  </a>
  <?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
  <div id="sdl_container">
   <div id="leftMenu">
    <div id="expandcontractdiv">
     <a id="collapseTree" href="javascript:tree.collapseAll()">
      Collapse all
     </a>
     <a id="index" href="index.html">
      Symbian^3 Application Developer Library
     </a>
    </div>
    <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">
     &#160;
    </div>
    <script type="text/javascript">
     var currentIconMode = 0; window.name="id2470542 id2397524 id2398594 id2398609 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
   </div>
   <div id="sdl_content">
<div class="breadcrumb">
     <a href="index.html" title="Symbian^3 Application Developer Library">
      Symbian^3 Application Developer Library
     </a>
     &gt;
     <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">
      Symbian Guide
     </a>
     &gt;
     <a href="GUID-975CBC70-81E6-5FA2-80CE-88DD2ABE9595.html">
      Graphics Guide
     </a>
     &gt;
     <a href="GUID-8C6D4350-A38D-57A1-8C8D-C777EA7E8A3E.html" title="The components within the EGL collection provide access to EGL on the Symbian platform. EGL, an open standard developed by the Khronos Group, provides an interface between rendering APIs such as OpenGL ES or OpenVG and an underlying native platform window system.">
      EGL Collection
     </a>
     &gt;
     <a href="GUID-D252E75C-C8CA-5C51-8DA3-95B937A1295C.html" title="The EGL Interface component provides a consistent interface to EGL on the Symbian platform, enabling cross-device compatibility. The component includes the Khronos-released header files (which incorporate some minor changes, such as to the in-source comments). It also provides some Symbian-specific header files and some other files (such as LIB, DEF and MMP files) and UIDs. It does not provide any implementations of the APIs.">
      EGL Interface Component
     </a>
     &gt;
    </div>
    <h1 class="topictitle1">
     Symbian-Specific Behavior
    </h1>
    <div>
     <p>
      This topic provides information about the points that the
EGL specification explicitly states are platform-specific. This information
is aimed at both users and implementers of EGL on the Symbian platform.
     </p>
     <div class="section" id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-E6A596AC-1BCE-4B99-89CF-67EE28A45068">
      <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-E6A596AC-1BCE-4B99-89CF-67EE28A45068">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       ScreenPlay
(NGA)
      </h2>
      <p>
       Applications can find out whether ScreenPlay (also
known as the New Graphics Architecture or NGA) is supported on the
device at runtime.
      </p>
      <p>
       To do this, call
       <samp class="codeph">
        eglQueryString(display,
EGL_EXTENSIONS)
       </samp>
       and search for the string
       <samp class="codeph">
        EGL_SYMBIAN_COMPOSITION
       </samp>
       within the string returned. If
       <samp class="codeph">
        EGL_SYMBIAN_COMPOSITION
       </samp>
       is present, it means that ScreenPlay is supported. For further information,
see
       <a href="GUID-2923A42C-1C0E-553D-8563-7B9FC51F153F.html" title="This topic describes the EGL functions that are defined as having platform-specific behavior and explains their expected behavior on the Symbian platform.">
        EGL Functions
with Symbian-Specific Behavior
       </a>
       .
      </p>
      <p>
       By checking for the presence
of the
       <samp class="codeph">
        EGL_SYMBIAN_COMPOSITION
       </samp>
       string, you can create
applications that can work on both ScreenPlay devices and those with
the non-ScreenPlay architecture.
      </p>
     </div>
     <div class="section" id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-5F4317DF-EEDE-434C-906D-A354367AE38D">
      <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-5F4317DF-EEDE-434C-906D-A354367AE38D">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Symbian
windows
      </h2>
      <p>
       EGL window surfaces are on-screen rendering surfaces
that are tied to Symbian windows. The
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       class
is a client-side handle to a Symbian Window Server window. You must
create the
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       before creating the EGL window
surface for on-screen rendering.
      </p>
      <p>
       Because the EGL window surface
is implemented differently depending on whether ScreenPlay is in use,
there are some differences in how you create an EGL window surface:
      </p>
      <ul>
       <li>
        <p>
         In ScreenPlay, the pixel format of the EGL window surface is
determined entirely by the EGL config passed to
         <samp class="codeph">
          eglCreateWindowSurface()
         </samp>
         and not by the properties of the
         <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
          <span class="apiname">
           RWindow
          </span>
         </a>
         .
        </p>
       </li>
       <li>
        <p>
         On a non-ScreenPlay device, the display mode of the
         <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
          <span class="apiname">
           RWindow
          </span>
         </a>
         must match the buffer size of the EGL window surface.
You can call
         <a href="GUID-1460DD8F-9AA1-3B99-8FFD-F309959CCA34.html#GUID-1460DD8F-9AA1-3B99-8FFD-F309959CCA34__GUID-FE6998EA-7B17-3270-B487-04D98EBB8424">
          <span class="apiname">
           RWindowBase::DisplayMode() const
          </span>
         </a>
         to
retrieve the windowâ€™s display mode and use it to determine the buffer
size when retrieving the EGL config to pass to
         <samp class="codeph">
          eglCreateWindowSurface()
         </samp>
         .
        </p>
       </li>
      </ul>
      <p>
       <strong>
        Threading
       </strong>
       . Because of the limitations of the Window
Server API, clients
       <strong>
        must
       </strong>
       create and use an EGL window surface
in the thread in which its
       <samp class="codeph">
        RWindow
       </samp>
       was created. This
means that the following are
       <strong>
        not
       </strong>
       supported and will lead to
undefined behavior:
      </p>
      <ul>
       <li>
        <p>
         Creating an EGL window surface in thread
         <em>
          B
         </em>
         using an
         <samp class="codeph">
          RWindow
         </samp>
         that was created in thread
         <em>
          A
         </em>
         .
        </p>
       </li>
       <li>
        <p>
         Using an EGL window surface in thread
         <em>
          B
         </em>
         when that EGL
window surface and its
         <samp class="codeph">
          RWindow
         </samp>
         were created in thread
         <em>
          A
         </em>
         .
        </p>
       </li>
      </ul>
      <p>
       For example, in the second scenario, EGL in thread
       <em>
        B
       </em>
       will fail (with a WSERV panic) when it attempts to get the window
size from the
       <samp class="codeph">
        RWindow
       </samp>
       in thread
       <em>
        A
       </em>
       .
      </p>
      <p>
       <strong>
        Buffer handling
       </strong>
       . By default EGL window surfaces have multiple
buffers, which means that the client can draw to a back buffer, while
the front buffer is being composed to the screen. The client must
call
       <samp class="codeph">
        eglSwapBuffers()
       </samp>
       to post the back buffer to
the screen.
      </p>
      <p>
       EGL 1.4 introduces a preserve buffer feature, which
enables the content of the front buffer to be preserved from one frame
to the next. This means that the client can provide incremental drawing
operations rather than the entire drawing operations for each frame.
This feature is usually off by default. This means that legacy applications
that do not expect this feature are not slowed down by the unnecessary
copying of the buffer contents.
      </p>
      <p>
       <strong>
        Window resizing
       </strong>
       . The
size of an applicationâ€™s view can be changed by a variety of external
events, such as a UI layout switch, a change in the size of the status
pane or the rotation of the screen.  An application can also resize
a window directly, such as through a call to
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html#GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79__GUID-BCD76117-54A3-3CD5-8911-E867512BF85B">
        <span class="apiname">
         RWindow::SetExtent()
        </span>
       </a>
       ,
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html#GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160__GUID-B680C675-2146-3162-AAAC-F3E88FA8B045">
        <span class="apiname">
         CCoeControl::SetExtent()
        </span>
       </a>
       or
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html#GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160__GUID-5A63E1BD-BCCA-356E-BB39-D4BB7B6DC22E">
        <span class="apiname">
         CCoeControl::SetExtentToWholeScreen()
        </span>
       </a>
       .
      </p>
      <p>
       When there is a change in the size of a window that is bound
to an EGL window surface, the application must take appropriate action
in its
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html#GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160__GUID-FFF07CE8-61C4-34F9-B9E9-D315782C8476">
        <span class="apiname">
         CCoeControl::SizeChanged(
        </span>
       </a>
       ) or
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html#GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160__GUID-1BC64D91-2796-3F16-AA41-13836BC00701">
        <span class="apiname">
         CCoeControl::HandleResourceChange()
        </span>
       </a>
       implementation. The action depends on the nature of the application
but might include clipping or scaling the contents to fit the resized
window.
      </p>
      <p>
       On the Symbian platform, EGL handles the window resize
in the next call to
       <samp class="codeph">
        eglSwapBuffers()
       </samp>
       , which resizes
the surface to match the new window size. If the preserve buffer option
is in use, this function also copies across all the pixels from the
old surface that overlap the new surface, although the exact details
depend on the implementation.
      </p>
      <p>
       If the surface resize fails,
       <samp class="codeph">
        eglSwapBuffers()
       </samp>
       returns
       <samp class="codeph">
        EGL_FALSE
       </samp>
       and
an
       <samp class="codeph">
        EGL_BAD_ALLOC
       </samp>
       error is raised. This may mean that
the implementation does not support the resizing of a surface or that
there is not enough memory available (on a platform with GPU, this
would be GPU rather than system memory). Applications must always
monitor whether
       eglSwapBuffers()
       fails after a
window resize. When it does fail, the application should do the following:
      </p>
      <ol>
       <li id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-81762FDD-72AD-410E-8E18-FFFF75CF6A32">
        <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-81762FDD-72AD-410E-8E18-FFFF75CF6A32">
         <!-- -->
        </a>
        <p>
         Call
         <samp class="codeph">
          eglDestroySurface()
         </samp>
         to destroy the current EGL window surface.
        </p>
       </li>
       <li id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-79FFA30C-1F31-47C0-9084-F72FF0E57FC6">
        <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-79FFA30C-1F31-47C0-9084-F72FF0E57FC6">
         <!-- -->
        </a>
        <p>
         Call
         <samp class="codeph">
          eglCreateWindowSurface()
         </samp>
         to recreate the EGL window surface.
        </p>
       </li>
      </ol>
      <p>
       This may cause a noticeable flicker and so should be done
only when necessary.
      </p>
      <p>
       <strong>
        Screen rotation
       </strong>
       . There is no specific
EGL handling for screen rotationâ€”instead screen rotation is handled
in the same way as a change of screen resolution. An application typically
handles changes in screen resolution and rotation in its
       <a href="GUID-3AC2CDAC-0291-309F-A020-049BC9F2CF90.html#GUID-3AC2CDAC-0291-309F-A020-049BC9F2CF90__GUID-5723655E-FC84-35F1-A0E1-FCE92CEBC196">
        <span class="apiname">
         CCoeAppUi::HandleScreenDeviceChangedL()
        </span>
       </a>
       or
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html#GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160__GUID-A925DD23-4531-3BA5-AF17-E6289F9E370A">
        <span class="apiname">
         CCoeControl::HandleResourceChange(TInt)
        </span>
       </a>
       implementation. When there is a change in screen rotation, the application
may need to resize its windows and update the content accordingly.
      </p>
      <p>
       The EGL implementation updates the surface size on the next call
to
       <samp class="codeph">
        eglSwapBuffers()
       </samp>
       .  However, the interim frames
appear in the new orientation, and so an application may want to adjust
the contents to minimize flicker. If the application wants to accept
the system rotation, it does not need to rotate its content. However,
some applications may require a fixed physical orientation. These
need to rotate the window content in order to counteract the physical
rotation.
      </p>
      <p>
       Sometimes a screen rotation simply results in the
swapping of the windowâ€™s width and height dimensionsâ€”for example,
when the application is running in full screen mode and the device
is rotated from portrait to landscape or vice versa. This is guaranteed
to succeed on all Symbian EGL implementations.
      </p>
      <p>
       In other situations
the screen rotation must be treated like a window resize and the application
must monitor whether
       <samp class="codeph">
        eglSwapBuffers()
       </samp>
       succeeds and
take appropriate action if it fails, as described above. For example,
if the application is not in full screen mode, rotating the device
from portrait to landscape may not result in the swapping of the width
and height of the window.
      </p>
      <p>
       <strong>
        UI content
       </strong>
       . Applications that
want to make use of the ScreenPlay ability to place semi-transparent
       <a href="GUID-0AEE5955-C530-35F1-A904-69183331B294.html">
        <span class="apiname">
         CWindowGc
        </span>
       </a>
       rendering above the EGL window surface should
check whether ScreenPlay is supported on the device as described above.
      </p>
      <p>
       On ScreenPlay devices, you can combine
       <a href="GUID-0AEE5955-C530-35F1-A904-69183331B294.html">
        <span class="apiname">
         CWindowGc
        </span>
       </a>
       drawing and OpenVG/OpenGL ES drawing in the same window, provided
the
       <a href="GUID-0AEE5955-C530-35F1-A904-69183331B294.html">
        <span class="apiname">
         CWindowGc
        </span>
       </a>
       content is drawn using a semi-transparent
pen or brush color or bitmap. It is also possible to create semi-transparent
       <a href="GUID-0AEE5955-C530-35F1-A904-69183331B294.html">
        <span class="apiname">
         CWindowGc
        </span>
       </a>
       drawing in another Symbian window placed over
the EGL window. To do this, make the Symbian window semi-transparent
by calling
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html#GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79__GUID-47275C08-0C58-3A03-B96F-38F881F49C08">
        <span class="apiname">
         RWindow::SetTransparencyAlphaChannel()
        </span>
       </a>
       .
       <a href="GUID-02BD38E7-A579-5BD5-9444-4E7C14C7809A.html" title="This topic introduces the window transparency feature, which you can use to create semi-transparent UI content over other UI content. In ScreenPlay you can also use transparent windows to create semi-transparent UI content over external content, such as video and OpenGL ES. For example, in ScreenPlay you can display a semi-transparent dialog box over an OpenGL ES game. Transparent windows are implemented using alpha compositing, which means that the transparency information is embedded within the drawing commands.">
        Transparent
Windows
       </a>
       has more detail on implementing semi-transparent windows.
      </p>
      <p>
       On non-ScreenPlay devices, you need to place the
       <a href="GUID-0AEE5955-C530-35F1-A904-69183331B294.html">
        <span class="apiname">
         CWindowGc
        </span>
       </a>
       drawing in an opaque child window over the EGL window surface or
implement the UI by using OpenVG/OpenGL ES drawing that is directed
to the EGL window surface itself.
      </p>
      <p>
       <strong>
        Window lifetime
       </strong>
       . Clients
must maintain the
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       associated with the EGL
window surface for the lifetime of that window surface, provided they
follow the good practice guidelines of unbinding the EGL window surface
from the current context before destroying it. If these guidelines
are not followed, it may be necessary to maintain the
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       for the entire duration of EGL usage within the client application.
      </p>
      <p>
       For example,  the following pseudocode demonstrates good practice.
The
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       must be valid until
       <samp class="codeph">
        eglDestroySurface()
       </samp>
       is called:
      </p>
      <pre class="codeblock">
       // Unbind the window surface from the current context.
eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);

// Destroy the window surface.
eglDestroySurface(display, surface);

...

eglTerminate(display)
      </pre>
      <p>
       When the application does not
follow this good practice and destroys the surface before unbinding
it from the current context, the
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       must be
valid for longer. For example in the following pseudocode,
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       must be valid until after
       <samp class="codeph">
        eglMakeCurrent()
       </samp>
       is called:
      </p>
      <pre class="codeblock">
       eglDestroySurface(display, surface);
eglMakeCurrent(display, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);

...

eglTerminate(display)
      </pre>
      <p>
       If
       eglMakeCurrent(
       ) is not called with a null surface and null context at all, the
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       must be valid until
       <samp class="codeph">
        eglTerminate()
       </samp>
       is called.
      </p>
     </div>
     <div class="section" id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-9BC770D9-3736-495E-8485-19D71700C50D">
      <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-9BC770D9-3736-495E-8485-19D71700C50D">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Symbian
pixmap types
      </h2>
      <p>
       An EGL implementation can support the
       <a href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html">
        <span class="apiname">
         CFbsBitmap
        </span>
       </a>
       pointer as an
       <samp class="codeph">
        EGLNativePixmapType
       </samp>
       . This means that it is possible to create an
       <samp class="codeph">
        EGLSurface
       </samp>
       to render to a
       <a href="GUID-683A1D42-2764-3EB7-BD19-9E12559199AB.html">
        <span class="apiname">
         CFbsBitmap
        </span>
       </a>
       . However, it is not
guaranteed to be supported on all EGL implementations.
      </p>
     </div>
     <div class="section" id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-44553B50-C48E-4E6B-AD9C-F3BC7D9D5347">
      <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-44553B50-C48E-4E6B-AD9C-F3BC7D9D5347">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Display
handling
      </h2>
      <p>
       Most EGL calls include an
       <samp class="codeph">
        EGLDisplay
       </samp>
       parameter. The EGL specification describes this as "the abstract
display on which graphics are drawn". On some systems, this corresponds
to a physical screen. However, the details are platform specific and
on Symbian systems, it does
       <em>
        not
       </em>
       correspond to a physical screen.
When working on the Symbian platform, it is generally more useful
to think of an
       <samp class="codeph">
        EGLDisplay
       </samp>
       as the EGL session.
      </p>
      <p>
       On Symbian systems, you usually use a single
       <samp class="codeph">
        EGLDisplay
       </samp>
       . You get this by a call to
       <samp class="codeph">
        eglGetDisplay()
       </samp>
       and
passing
       <samp class="codeph">
        EGL_DEFAULT_DISPLAY
       </samp>
       as the
       <samp class="codeph">
        &lt;display
id&gt;
       </samp>
       parameter.
      </p>
      <p>
       The physical screen on which the content
is displayed is determined by the window's parent window group. In
Symbian, every window (
       <a href="GUID-683603DD-F3D3-3193-BEB3-8236C7DE7F79.html">
        <span class="apiname">
         RWindow
        </span>
       </a>
       ) has a parent window
group (
       <a href="GUID-64D4D428-D65F-3D9D-A0D4-C8338C848B25.html">
        <span class="apiname">
         RWindowGroup
        </span>
       </a>
       ), as shown in the following
diagram. When you create a window group, you can specify the screen
on which it is to be shown.
      </p>
      <div class="fignone" id="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-5D5F3C6A-4CFA-5307-8B2D-D2881799D664">
       <a name="GUID-894AB487-C127-532D-852B-37CB0DEA1440__GUID-5D5F3C6A-4CFA-5307-8B2D-D2881799D664">
        <!-- -->
       </a>
       <span class="figcap">
        Figure 1. Each window has a parent window group which is associated with
a screen
       </span>
       <img src="GUID-CF9EF400-DE1F-55F7-BD33-C4CD80462971_d0e211248_href.png" />
      </div>
      <p>
       When you create a window surface in EGL using
       <samp class="codeph">
        eglCreateWindowSurface
       </samp>
       , you pass in the
       <samp class="codeph">
        RWindow
       </samp>
       as an argument. The window
surface is then displayed on the screen associated with that window's
parent window group. Currently a window can exist on only one screen.
      </p>
     </div>
    </div>
    <div>
     <div class="familylinks">
      <div class="parentlink">
       <strong>
        Parent topic:
       </strong>
       <a href="GUID-D252E75C-C8CA-5C51-8DA3-95B937A1295C.html" title="The EGL Interface component provides a consistent interface to EGL on the Symbian platform, enabling cross-device compatibility. The component includes the Khronos-released header files (which incorporate some minor changes, such as to the in-source comments). It also provides some Symbian-specific header files and some other files (such as LIB, DEF and MMP files) and UIDs. It does not provide any implementations of the APIs.">
        EGL Interface Component
       </a>
      </div>
     </div>
     <div class="relinfo relconcepts">
      <strong>
       Related concepts
      </strong>
      <br />
      <div>
       <a href="GUID-D252E75C-C8CA-5C51-8DA3-95B937A1295C.html" title="The EGL Interface component provides a consistent interface to EGL on the Symbian platform, enabling cross-device compatibility. The component includes the Khronos-released header files (which incorporate some minor changes, such as to the in-source comments). It also provides some Symbian-specific header files and some other files (such as LIB, DEF and MMP files) and UIDs. It does not provide any implementations of the APIs.">
        EGL
Interface Component
       </a>
      </div>
      <div>
       <a href="GUID-DC8BFEF5-DA50-52DA-8CE2-5729A4A005F6.html" title="EGL is an interface between EGL client APIs (such as OpenGL ES and OpenVG) and an underlying native platform window system. EGL is independent of definitions and concepts specific to any native window system or rendering API.">
        EGL
Collection Overview
       </a>
      </div>
      <div>
       <a href="GUID-53707903-9A88-409B-80F8-FDF7EF47ACBF.html" title="This example application demonstrates creating semi-transparent UI content over OpenVG content that is rendered to a composition surface. This is only possible when ScreenPlay is enabled.">
        Coverflow:
using ScreenPlay
       </a>
      </div>
      <div>
       <a href="GUID-484B51EC-2209-5492-8E9C-9D792AB0DF35.html" title="This section provides application developers with an introduction to key concepts involved in drawing graphics to the screen.">
        Drawing
with CWindowGc
       </a>
      </div>
     </div>
    </div>
    <p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
   </div>
  </div>
  <?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>
 </body>
</html>
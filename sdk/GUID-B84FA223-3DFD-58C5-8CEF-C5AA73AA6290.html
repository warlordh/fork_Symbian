<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="copyright" content="(C) Copyright 2010" />
  <meta name="DC.rights.owner" content="(C) Copyright 2010" />
  <meta name="DC.Type" content="concept" />
  <meta name="DC.Title" content="How to write controls" />
  <meta name="DC.Relation" scheme="URI" content="GUID-6C16417B-5B37-5310-B59A-750D971AA6D4.html" />
  <meta name="DC.Relation" scheme="URI" content="index.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-94005A46-B4C6-4A30-A8E8-1B9C2D583D50.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-E079315A-E5B6-4D33-B7E3-88697A3F11A4.html" />
  <meta name="DC.Relation" scheme="URI" content="GUID-6C16417B-5B37-5310-B59A-750D971AA6D4.html" />
  <meta name="DC.Format" content="XHTML" />
  <meta name="DC.Identifier" content="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290" />
  <meta name="DC.Language" content="en" />
  <link rel="stylesheet" type="text/css" href="commonltr.css" />
  <title>
   How to write controls
  </title>
  <link type="text/css" rel="stylesheet" href="css/common.css" media="screen"/>
<link type="text/css" rel="stylesheet" href="css/sdl.css" media="screen"/>

<!--[if IE]>
<link href="css/iefix.css" rel="stylesheet" type="text/css" media="screen" />
<![endif]-->
  <link rel="stylesheet" type="text/css" href="nokiacxxref.css" />
 </head>
 <body id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290">
  <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290">
   <!-- -->
  </a>
  <?php include_once (CURRENT_SKIN_PATH.'/sdl_header.html'); ?>
  <div id="sdl_container">
   <div id="leftMenu">
    <div id="expandcontractdiv">
     <a id="collapseTree" href="javascript:tree.collapseAll()">
      Collapse all
     </a>
     <a id="index" href="index.html">
      Symbian^3 Application Developer Library
     </a>
    </div>
    <iframe style="border:none" height="800" width="300" src="index-toc.html"></iframe>
<div id="treeDiv1">
     &#160;
    </div>
    <script type="text/javascript">
     var currentIconMode = 0; window.name="id2470542 id2469732 id2469004 id2468931 ";
	YAHOO.util.Event.onDOMReady(buildTree, this,true);
    </script>
   </div>
   <div id="sdl_content">
<div class="breadcrumb">
     <a href="index.html" title="Symbian^3 Application Developer Library">
      Symbian^3 Application Developer Library
     </a>
     &gt;
     <a href="GUID-32E29020-1956-461A-B79A-1492E06049E7.html" title="The Symbian Guide describes the architecture and functionality of the platform, and provides guides on using its APIs.">
      Symbian Guide
     </a>
     &gt;
     <a href="GUID-94005A46-B4C6-4A30-A8E8-1B9C2D583D50.html">
      Classic UI Guide
     </a>
     &gt;
     <a href="GUID-E079315A-E5B6-4D33-B7E3-88697A3F11A4.html">
      Control and animation framework
     </a>
     &gt;
     <a href="GUID-6C16417B-5B37-5310-B59A-750D971AA6D4.html">
      The UI Control Framework (CONE)
     </a>
     &gt;
    </div>
    <h1 class="topictitle1">
     How to
write controls
    </h1>
    <div>
     <p>
      Cone itself does not provide any concrete controls. Uikon and the UI variant
libraries provide a large number of 'stock' controls for application writers.
Application writers often need to supplement the standard set of controls
with application specific controls of their own. These may be completely new
controls or, more often, compound controls which contain a number of standard
controls.
     </p>
     <p>
      This section describes how to create controls and how to integrate them
in to the control framework. It is divided into the following sections:
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-341017B2-8CF9-5124-8D20-C75A8A51F0B7">
       Creating
a control
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-3F0E8223-2218-5C95-AFBC-D66AD1DB12A7">
       Window
owning or not?
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-795EBF51-AD26-513E-9A82-A99C629CE779">
       Creating
a compound control
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-795EBF51-AD26-513E-9A82-A99C629CE779">
       Size,
position and layout
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-351911EE-87C7-5D11-8434-BA7FD3741745">
       Drawing
and refreshing
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-FF7DB067-24AD-50C3-BF52-952F836609B0">
       Drawing
backgrounds
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-54C6A39A-CBD0-52E5-8CD0-76BE22247A54">
       Drawing
text
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-D1AED2A8-94AC-54BB-9CEB-C8C3643AFBBD">
       Drawing
graphics
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-AC723EE4-1482-59C5-9F13-CAE119C7800D">
       Handling
events
      </a>
     </p>
     <p>
      <a href="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290.html#GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-FE221E89-1817-5A73-8FBA-212FBC030766">
       Implementing
the Object Provider (MOP) interface
      </a>
     </p>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-341017B2-8CF9-5124-8D20-C75A8A51F0B7">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-341017B2-8CF9-5124-8D20-C75A8A51F0B7">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Creating a
control
      </h2>
      <p>
       A control is a class which derives from
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html">
        <span class="apiname">
         CCoeControl
        </span>
       </a>
       .
It should have a public constructor and, if any leaving function calls or
memory allocations are required during construction, a
       <samp class="codeph">
        ConstructL()
       </samp>
       function.
The majority of re-useable and configurable controls have a
       <samp class="codeph">
        ConstructFromResourceL()
       </samp>
       function
which allows a specific instance of a control to be configured using an application's
resource file. Obviously any memory allocated must be freed in the destructor.
Before a control is drawn to the screen it must be activated. The
       <samp class="codeph">
        ActivateL()
function
       </samp>
       may be overriden to perform last-minute configuration (but
must call the function in the base class).
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-18D48E7E-9846-5CE0-BE1E-FAB723419B90">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-18D48E7E-9846-5CE0-BE1E-FAB723419B90">
        <!-- -->
       </a>
       Class CMyControl : public CCoeControl
    {
    public:
        CMyControl() ;
        void ConstructL(...) ;
        // from CCoeControl
        void ConsructFromResourceL( TResourceReader&amp; aReader ) ; 
    private:
        ~CMyControl() ;

    // additional functions to handle events 
    // additional functions to draw the control
    // additional functions to determine the size, layout and position the control
    }
      </pre>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-3F0E8223-2218-5C95-AFBC-D66AD1DB12A7">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-3F0E8223-2218-5C95-AFBC-D66AD1DB12A7">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Window owning
or not?
      </h2>
      <p>
       The decision over whether to make a control window owning
or not is usually straightforward. Each view requires a window, so the top-level
control must be window-owning and a child of the AppUi. Below this a window
owning control is normally only necessary where a sense of layering is required:
for instance a pop-up window or a scrolling window. Dialogs and menus are
window owning controls but these are normally implemented in the Uikon and
UI variant libraries and do not require custom derivation from
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html">
        <span class="apiname">
         CCoeControl
        </span>
       </a>
       .
Unnecessary window-owning controls should be avoided as they require more
infrastructure, place greater demand on the Window Server and reduce performance.
      </p>
      <p>
       If
a control must be window owning its window must either be created in the
       <samp class="codeph">
        ConstructL()
       </samp>
       function
or by the caller. The former is preferred. There are several overloads of
the
       <samp class="codeph">
        CreateWindowL()
       </samp>
       and
       <samp class="codeph">
        CreateBackedUpWindowL()
       </samp>
       functions.
Those which do not take a parent parameter create a top-level window which
is a child of the root window.
      </p>
      <p>
       If a control is not window owning its
       <samp class="codeph">
        SetContainerWindowL()
       </samp>
       function
must be called when it is instantiated.
      </p>
      <p>
       If it can, the Framework will
automatically set up the parent pointer when the window, or associated window
relationship is established. If it cannot do this, because
       <samp class="codeph">
        CreateWindowL()
       </samp>
       or
       <samp class="codeph">
        SetContainerWindowL()
       </samp>
       did
not provide a
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html">
        <span class="apiname">
         CCoeControl
        </span>
       </a>
       , the parent pointer (and MopParent)
may be set expicitly using
       <samp class="codeph">
        SetParent()
       </samp>
       and
       <samp class="codeph">
        SetMopParent()
       </samp>
       .
      </p>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-795EBF51-AD26-513E-9A82-A99C629CE779">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-795EBF51-AD26-513E-9A82-A99C629CE779">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Creating a
compound control
      </h2>
      <p>
       Most applications UIs are built from compound
controls. Many custom controls are built up from stock controls and are therefore
also compound controls. When a compound control is constructed it constructs
its components in its
       <samp class="codeph">
        ConstructL()
       </samp>
       function. When it receives
commands itself, such as
       <samp class="codeph">
        ActivateL()
       </samp>
       and
       <samp class="codeph">
        DrawNow()
       </samp>
       it
passes them on to each of its components. In most cases the Framework does
much of the donkey work as long as the compound control has been constructed
correctly.
      </p>
      <p>
       There are now two methods of creating and managing lodger
controls. The first method described is the one that should be used.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-F77661F7-6A68-58DB-B875-9D957A937617">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-F77661F7-6A68-58DB-B875-9D957A937617">
        <!-- -->
       </a>
       void MyControl::ConstructL( ... )
    {
    // initialise the component array. This must be called once (subsequent calls have no effect)
    InitComponentArrayL() ; 

    // construct each component control and add it to the component array.
    CComponent* myComponent = new (ELeave) CComponent ;
    Components().AppendLC( myComponent ) ; // or InsertLC or InsertAfterLC().  Places item on cleanup stack.
    myComponent-&gt;ConstructL() ;
    myComponent-&gt;SetThisAndThatL() ;
    CleanupStack::Pop( myComponent ) ;    
    }
      </pre>
      <p>
       The return value of the insert and append methods is
a
       <a href="GUID-2D8BFBA2-79AC-364D-875D-E863CD4A2FE1.html#GUID-2D8BFBA2-79AC-364D-875D-E863CD4A2FE1__GUID-AD37D86C-F9FA-3514-BFD4-7139A0B8543F">
        <span class="apiname">
         CCoeControlArray::TCursor
        </span>
       </a>
       object which works as an iterator.
It will remain valid when other items are inserted or deleted, or even if
the whole array is re-ordered.
      </p>
      <p>
       The insert and append methods leave
the component on the Cleanup Stack using a dedicated Cleanup Item that protects
the parent's array as well as the component itself.
      </p>
      <p>
       The insert and
append methods allow each component to be given an ID. The ID must be unique
only within the parent so typically a compound control will have an enum listing
each of its children's IDs.
       <a href="GUID-2D8BFBA2-79AC-364D-875D-E863CD4A2FE1.html">
        <span class="apiname">
         CCoeControlArray
        </span>
       </a>
       , accessed
using
       <samp class="codeph">
        CCoeControl::Components()
       </samp>
       , has a
       <samp class="codeph">
        ControlById()
       </samp>
       method
to retrieve components using their IDs.
      </p>
      <p>
       Components in the array are,
by default, owned by the parent and will be deleted automatically when the
parent is deleted. The default may be overridden using
       <samp class="codeph">
        CCoeControlArray::SetControlsOwnedExternally()
       </samp>
       .
The setting applies to all of the components.
      </p>
      <p>
       Controls may be removed
from the array using one of the
       <samp class="codeph">
        Remove()
       </samp>
       methods. These do
not delete.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-9F9EC327-E7DE-59B8-838B-F5052E3750D3">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-9F9EC327-E7DE-59B8-838B-F5052E3750D3">
        <!-- -->
       </a>
       class CCoeControlArray
        ...
    public:
        IMPORT_C TInt Remove(const CCoeControl* aControl);
        IMPORT_C CCoeControl* Remove(TCursor aRemoveAt);
        IMPORT_C CCoeControl* RemoveById(TInt aControlId);
        ...
      </pre>
      <p>
       Using the component array as described is now the approved
method of constructing and managing compound controls. In older versions of
Symbian OS a specific method of handling components was not provided and developers
were obliged to design their own. Bypassing the component array is still possible.
It is necessary to allocate and store the components (typically as member
data) and to implement the
       <samp class="codeph">
        CountComponentControls()
       </samp>
       and
       <samp class="codeph">
        ComponentControl()
       </samp>
       functions
to return the number of components and a specified component to the framework.
The new method offers significant advantages when controls are added and removed
dynamically or are dependant on run-time data. The new method is also integrated
with new layout managers.
      </p>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-7E144310-9AF4-50F1-AD8A-9F9E05D554D1">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-7E144310-9AF4-50F1-AD8A-9F9E05D554D1">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Size, position
and layout
      </h2>
      <p>
       There are several factors which contribute to a control's
size and position. The control itself will require a certain size in order
to display itself (and its data) correctly. The control's container will be
responsible for positioning the control but is also likely to be responsible
for positioning other controls - each of which will have its own requirements.
Additionally there are the requirements of the UI's look and feel that must
be complied with.
      </p>
      <p>
       Each control is responsible for implementing its
own
       <samp class="codeph">
        Size()
       </samp>
       function.
      </p>
      <p>
       Until Symbian OS version 9.1
it was normal to write layout code for simple and compound controls in the
       <samp class="codeph">
        SizeChanged()
       </samp>
       function.
This is called by the framework, as one might expect, when a control's size
(its 'extent') is changed. From 9.1, however, Symbian OS supports the use
of the layout manager interface (
       <a href="GUID-A622B8C7-60F4-38E8-B102-14883BCBA249.html">
        <span class="apiname">
         MCoeLayoutManager
        </span>
       </a>
       ) and
the
       <samp class="codeph">
        SizeChanged()
       </samp>
       function is now implemented in the base
class. (Note that if a control's position is changed, with no size change,
using
       <samp class="codeph">
        CCoeControl::SetPosition()
       </samp>
       its
       <samp class="codeph">
        PositionChanged()
       </samp>
       function
is called and that default implementation of
       <samp class="codeph">
        PositionChanged()
       </samp>
       is
empty).
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-53A10820-550A-52C2-AE80-D556FD77E8FA">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-53A10820-550A-52C2-AE80-D556FD77E8FA">
        <!-- -->
       </a>
       class MCoeLayoutManager
        ...
    protected:
        IMPORT_C MCoeLayoutManager();
    
    public:
        virtual TBool CanAttach() const = 0;
        virtual void AttachL(CCoeControl&amp; aCompoundControl) = 0;
        virtual void Detach(CCoeControl&amp; aCompoundControl) = 0;
        virtual TSize CalcMinimumSize(const CCoeControl&amp; aCompoundControl) const = 0;
        virtual void PerformLayout() = 0;
        virtual TInt CalcTextBaselineOffset(const CCoeControl&amp; aCompoundControl, const TSize&amp; aSize) const = 0;
        virtual void SetTextBaselineSpacing(TInt aBaselineSpacing) = 0;
        virtual TInt TextBaselineSpacing() const = 0;
        virtual void HandleAddedControlL(const CCoeControl&amp; aCompoundControl, const CCoeControl&amp; aAddedControl) = 0;
        virtual void HandleRemovedControl(const CCoeControl&amp; aCompoundControl, const CCoeControl&amp; aRemovedControl) = 0;
        virtual TInt HandleControlReplaced(const CCoeControl&amp; aOldControl, const CCoeControl&amp; aNewControl) = 0;
        ...
      </pre>
      <p>
       A layout manager may be attached to a compound control.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-ACCD143C-8618-5606-B749-D7EFE5C83ACD">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-ACCD143C-8618-5606-B749-D7EFE5C83ACD">
        <!-- -->
       </a>
       class CCoeControl
        ...
    protected: 
        IMPORT_C MCoeLayoutManager* LayoutManager() const;
        IMPORT_C virtual void SetLayoutManagerL(MCoeLayoutManager* aLayoutManager);

    public:
        IMPORT_C virtual TBool RequestRelayout(const CCoeControl* aChildCtrl);
        ...
      </pre>
      <p>
       The default implementations of
       <samp class="codeph">
        MinimumSize()
       </samp>
       and
       <samp class="codeph">
        SizeChanged()
       </samp>
       now
use the layout manager.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-88340A33-A58C-5856-AD47-C2E1637DD45F">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-88340A33-A58C-5856-AD47-C2E1637DD45F">
        <!-- -->
       </a>
       EXPORT_C TSize CCoeControl::MinimumSize()
    { 
    const MCoeLayoutManager* layoutManager = LayoutManager();
    if (layoutManager)
        return layoutManager-&gt;CalcMinimumSize(*this);
    else    
        return iSize;
    }

EXPORT_C void CCoeControl::SizeChanged()
    {
    MCoeLayoutManager* layout = LayoutManager();
    if (layout)
        layout-&gt;PerformLayout();
      </pre>
      <p>
       The layout manager is responsible for the size and position
of the component controls. In practice it's likely that the UI variant libraries
will provide concrete layout managers. Application developers should use these
as the basis for control-specific layout managers.
      </p>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-351911EE-87C7-5D11-8434-BA7FD3741745">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-351911EE-87C7-5D11-8434-BA7FD3741745">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Drawing and
refreshing
      </h2>
      <p>
       A fundamental requirement of most controls is that they
are able to render themselves onto the screen. For most controls the drawing
process involves outputting text, painting backgrounds (either plain or from
a bitmap), drawing shapes (graphics objects) and drawing component controls.
      </p>
      <p>
       Screen
drawing may be initiated by the application itself, following something within
the application changing, or by the Window Server, due to something else in
the system updating the screen while the application is visible. In both cases
the control's
       <samp class="codeph">
        Draw()
       </samp>
       function will be called automatically
by the framework. For compound controls all of the components'
       <samp class="codeph">
        Draw()
       </samp>
       functions
will also be called - unless the component lies completely outside the area
that requires redrawing.
      </p>
      <p>
       As a control writer you will probably have
to implement a
       <samp class="codeph">
        Draw()
       </samp>
       function.
      </p>
      <p>
       Here is the signature
for
       <samp class="codeph">
        Draw()
       </samp>
       :
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-7A83E8B5-9673-5EBC-B628-674734A07E0F">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-7A83E8B5-9673-5EBC-B628-674734A07E0F">
        <!-- -->
       </a>
       private:
    void Draw( const TRect&amp; aRect ) const ;
      </pre>
      <p>
       Note that it
is private, takes a
       <samp class="codeph">
        const TRect&amp;
       </samp>
       as a parameter, must
not leave and is
       <samp class="codeph">
        const
       </samp>
       .
      </p>
      <p>
       It should only be called
by the framework. Application initiated redraws should be through calls to
       <samp class="codeph">
        DrawNow()
       </samp>
       ,
       <samp class="codeph">
        DrawDeferred()
       </samp>
       or
custom functions for drawing smaller elements.
      </p>
      <p>
       The
       <samp class="codeph">
        aRect
       </samp>
       parameter
is the part of the control that requires drawing (refreshing).
      </p>
      <p>
       The
function is
       <samp class="codeph">
        const
       </samp>
       and non-leaving because it is intended
to support the decoupling of drawing actions from application state.
      </p>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-FF7DB067-24AD-50C3-BF52-952F836609B0">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-FF7DB067-24AD-50C3-BF52-952F836609B0">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Drawing backgrounds
      </h2>
      <p>
       A
control's background is typically determined by the current colour scheme
or skin. It may be a plain colour or a bitmap. It's also possible that a control
is to appear non-rectangular or transparent in which case some of the background
will be the control underneath. Prior to Symbian OS 9.1 controls were required
to clear and update their whole area and creating these effects was rather
complex. From 9.1 controls are drawn 'backmost first'.
      </p>
      <p>
       Background
drawing should be done by a dedicated background drawer - i.e. an object which
implements the
       <a href="GUID-88936D48-B801-3D9C-8A9D-3498807937CE.html">
        <span class="apiname">
         MCoeControlBackground
        </span>
       </a>
       interface. A background
can be attached to a
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html">
        <span class="apiname">
         CCoeControl
        </span>
       </a>
       using
       <samp class="codeph">
        SetBackground()
       </samp>
       and
is used for that control and all of its children. When a control is drawn
the framework looks for the nearest background up the run-time hierarchy and
calls
       <samp class="codeph">
        MCoeControlBackground::Draw()
       </samp>
       .
      </p>
      <p>
       UI variant libraries
typically provide backgrounds. They are not owned by the controls to which
they are attached.
      </p>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-54C6A39A-CBD0-52E5-8CD0-76BE22247A54">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-54C6A39A-CBD0-52E5-8CD0-76BE22247A54">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Drawing text
      </h2>
      <p>
       Text
must be drawn with the correct color, font, size and direction. As with backgrounds,
these are determined at runtime according to UI customizations. This is achieved
by means of a Text Drawer. Note the use of the
       <a href="GUID-2280260C-3A4F-3C1E-ADF2-3219ED7FE0DE.html">
        <span class="apiname">
         XCoeTextDrawer
        </span>
       </a>
       class.
This is a smart pointer (note the use of the
       <samp class="codeph">
        -&gt;
       </samp>
       operator
to access
       <a href="GUID-C8C7B785-B3CF-3488-AEB1-BE0A70F6C1F2.html">
        <span class="apiname">
         CCoeTextDrawerBase
        </span>
       </a>
       functions) which ensures that
only one text drawer is allocated on the heap at a time.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-511A9CEE-F02C-5667-A334-3C61A2428F0F">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-511A9CEE-F02C-5667-A334-3C61A2428F0F">
        <!-- -->
       </a>
       XCoeTextDrawer textDrawer( TextDrawer() );
textDrawer-&gt;SetAlignment(iAlignment); 
textDrawer-&gt;SetMargins(iMargin);
textDrawer-&gt;SetLineGapInPixels(iGapBetweenLines);
textDrawer.SetClipRect(aRect); // have to use . [dot] operator for SetClipRect() as not CCoeTextDrawerBase function.

textDrawer.DrawText(gc, *iTextToDraw, Rect(), *Font());
      </pre>
      <p>
       Text drawers are typically provided by the UI variant library
or skin manager. Controls within the run-time hierarchy can set the text drawer
for their children by overriding
       <samp class="codeph">
        GetTextDrawer()
       </samp>
       .
      </p>
      <p>
       Note
that the text drawer expects text to be passed as a
       <a href="GUID-07D86324-ED54-3FCD-B301-53B7A6E04AE3.html">
        <span class="apiname">
         TBidiText
        </span>
       </a>
       rather
than a descriptor. Controls should store all display text in
       <a href="GUID-07D86324-ED54-3FCD-B301-53B7A6E04AE3.html">
        <span class="apiname">
         TBidiText
        </span>
       </a>
       objects.
Application writers should consider the implications of right-to-left layouts
for languages such as Hebrew and Arabic.
      </p>
      <p>
       A control's
       <samp class="codeph">
        GetTextDrawer()
       </samp>
       function
might look something like this. It checks on the current state of the control
(
       <samp class="codeph">
        IsDimmed()
       </samp>
       ) and passes the call on to a skin manager.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-155AD8EC-17DD-5155-BE20-23246A33695C">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-155AD8EC-17DD-5155-BE20-23246A33695C">
        <!-- -->
       </a>
       EXPORT_C void CMyButtonControl::GetTextDrawer(CCoeTextDrawerBase*&amp; aTextDrawer, const CCoeControl* aDrawingControl, TInt /*aKey*/) const
    {
    const TInt textDrawerIndex = (IsDimmed() ? EButtonTextDimmed : EButtonText);

    SkinManager::GetTextDrawer(aTextDrawer, KSkinUidButton, textDrawerIndex, aDrawingControl);
    }
      </pre>
      <p>
       If the control is drawing text on its own graphics (and does
not care about the text drawer of its parents) it can just create an
       <a href="GUID-2280260C-3A4F-3C1E-ADF2-3219ED7FE0DE.html">
        <span class="apiname">
         XCoeTextDrawer
        </span>
       </a>
       object
on the stack in its
       <samp class="codeph">
        Draw()
       </samp>
       method and initiate it from the
skin that it is currently using to draw its graphics, using the
       <samp class="codeph">
        CSkinPatch::TextDrawer()
       </samp>
       method,
like this:
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-3DFDBF27-8744-5283-AC7B-EC512EEEBB7D">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-3DFDBF27-8744-5283-AC7B-EC512EEEBB7D">
        <!-- -->
       </a>
       const CSkinPatch&amp; skin = SkinManager::SkinPatch(KSomeSkinUid, KSomeSkinIndex, this);

skin.DrawBitmap(gc, Rect(), aRect);
XCoeTextDrawer textDrawer( skin.TextDrawer(KSomeSkinUid, ESomeSkinTextDimmed, this) );

const CFont&amp; font = ScreenFont(TCoeFont::NormalFont);
textDrawer.DrawText(gc, iText, rect, font);
      </pre>
      <p>
       The example above also illustrates how to retrieve the correct
font.
       <a href="GUID-2A12FE3B-47F2-3016-8161-A971CA506491.html">
        <span class="apiname">
         CFont
        </span>
       </a>
       objects must not be stored in control member
data as they must change when the control's zoom state changes. Instead, a
       <a href="GUID-463C1928-878D-3B06-ABFD-178BE1BAD776.html">
        <span class="apiname">
         TCoeFont
        </span>
       </a>
       that
represents a font's size (logical or absolute in pixels) and style (plain,
bold, italic, subscript, or superscript) should be used.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-864A57DB-BCDA-50B6-B876-9EF62CFB27C6">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-864A57DB-BCDA-50B6-B876-9EF62CFB27C6">
        <!-- -->
       </a>
       class TCoeFont 
        ...
    public: 
        IMPORT_C TCoeFont(TLogicalSize aSize, TInt aStyle, TInt aFlags = ENoFlags); 
        IMPORT_C TCoeFont(TInt aHeightInPixels, TInt aStyle, TInt aFlags = ENoFlags); 
        IMPORT_C TCoeFont(const TCoeFont&amp; aFont);
        IMPORT_C TCoeFont();
        ...
      </pre>
      <p>
       By creating a
       <a href="GUID-463C1928-878D-3B06-ABFD-178BE1BAD776.html">
        <span class="apiname">
         TCoeFont
        </span>
       </a>
       object
describing the properties of the desired font, a
       <a href="GUID-2A12FE3B-47F2-3016-8161-A971CA506491.html">
        <span class="apiname">
         CFont
        </span>
       </a>
       object
reference (needed to actually draw the text) can be fetched from the
       <a href="GUID-372CDE49-2148-3A21-8EA3-8D4656548C23.html">
        <span class="apiname">
         CCoeFontProvider
        </span>
       </a>
       .
A font provider can be attached to any
       <a href="GUID-B06F99BD-F032-3B87-AB26-5DD6EBE8C160.html">
        <span class="apiname">
         CCoeControl
        </span>
       </a>
       and
will keep information about the typeface used by that control and all controls
below. A default font provider is attached to the
       <a href="GUID-12A9389D-363B-3F54-857F-89EE0EDCDF40.html">
        <span class="apiname">
         CCoeEnv
        </span>
       </a>
       .
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-C46BEB52-33DB-564B-9A64-53763C7CD226">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-C46BEB52-33DB-564B-9A64-53763C7CD226">
        <!-- -->
       </a>
       class CCoeControl
        ...
    public:
        IMPORT_C const CCoeFontProvider&amp; FindFontProvider() const;
        IMPORT_C void SetFontProviderL(const CCoeFontProvider&amp; aFontProvider);
        ...
      </pre>
      <p>
       To get hold of the
       <a href="GUID-2A12FE3B-47F2-3016-8161-A971CA506491.html">
        <span class="apiname">
         CFont
        </span>
       </a>
       object
a
       <samp class="codeph">
        Draw()
       </samp>
       method can be implemented like this:
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-45292362-1E39-59B0-AC7F-14C98592F059">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-45292362-1E39-59B0-AC7F-14C98592F059">
        <!-- -->
       </a>
       void CMyControl::Draw(const TRect&amp; aRect)
    {
    const CCoeFontProvider&amp; fontProvider = FindFontProvider();
    const CFont&amp; font = fontProvider.Font(TCoeFont::LegendFont(), AccumulatedZoom());

    XCoeTextDrawer textDrawer( TextDrawer() );
    textDrawer-&gt;SetAlignment(EHCenterVCenter);
    textDrawer.DrawText(gc, iText, rect, font);
    }
      </pre>
      <p>
       For convenience there’s a
       <samp class="codeph">
        CCoeControl::ScreenFont()
       </samp>
       method
that locates the font provider and calls it with the control’s accumulated
zoom:
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-5974F900-84B7-5262-8428-88797911F94A">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-5974F900-84B7-5262-8428-88797911F94A">
        <!-- -->
       </a>
       class CCoeControl
        ...
    protected:
        IMPORT_C const CFont&amp; ScreenFont(const TCoeFont&amp; aFont) const;
        ...
      </pre>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-D1AED2A8-94AC-54BB-9CEB-C8C3643AFBBD">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-D1AED2A8-94AC-54BB-9CEB-C8C3643AFBBD">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Drawing graphics
      </h2>
      <p>
       Controls
draw graphics objects - lines, rectangles, shapes and bitmaps to a
       <span class="keyword">
        graphics
context
       </span>
       . The graphics context is provided by the Window Server and
represents a group of settings appropriate for the physical device that is
ultimately being drawn to. In most cases the device is a screen and a graphics
context should be obtained using
       <samp class="codeph">
        CCoeControl::SystemGc()
       </samp>
       .
       <samp class="codeph">
        CCoeControl::SystemGc()
       </samp>
       gets
the current graphics context from the run-time hierarchy. Controls in the
hierarchy may override graphics context settings which will then be passed
on to their children.
       <em>
        Controls should not get their graphics context directly
from CCoeEnv as to do so would bypass the hierarchy
       </em>
       .
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-DC2B7A84-BA93-5AE0-BABA-9CF6B156A54E">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-DC2B7A84-BA93-5AE0-BABA-9CF6B156A54E">
        <!-- -->
       </a>
       void CMyControl::Draw( const TRect&amp; aRect )
    {
    CWindowGc&amp; gc = SystemGc() ; // get gc from run time hierarchy
    TRect rect = TRect( Size() ) ;
    if ( IsBlanked() )
        {
        // blank out the entire control
        gc.SetPenStyle( CGraphicsContext::ENullPen ) ;
        gc.SetBrushStyle( CGraphicsContext::ESolidBrush ) ;
        TRgb blankColor = BlankingColor() ;
        gc.SetBrushColor( blankColor ) ;
        gc.DrawRect( rect ) ;
        }
    else
        {
        // draw masked bitmap in the centre of the control 
        // The parent will draw the background 
        TInt id = BitMapId() ;

        TInt x = Size().iWidth - iBitmap[id]-&gt;SizeInPixels().iWidth ;
        TInt y = Size().iHeight - iBitmap[id]-&gt;SizeInPixels().iHeight ;

        TPoint pos = Rect().iTl ;
        pos.iX = pos.iX + ( x / 2 ) ;
        pos.iY = pos.iY + ( y / 2 ) ;

        gc.BitBltMasked( pos, iBitmap[id], rect, iMaskBitmap, ETrue ) ;
        }
    }
      </pre>
      <p>
       Before a graphics context can be used it must be activated.
After use it must be deactivated. Activation and deactivation are done automatically
by the framework in
       <samp class="codeph">
        DrawNow()
       </samp>
       ,
       <samp class="codeph">
        DrawDeferred()
       </samp>
       and
       <samp class="codeph">
        HandleRedrawEvent()
       </samp>
       but
must be done explicitly for any other application initiated drawing by calling
       <samp class="codeph">
        ActivateGc()
       </samp>
       and
       <samp class="codeph">
        DeactivateGc()
       </samp>
       .
      </p>
      <p>
       Controls may implement partial drawing to speed up performance. The
       <samp class="codeph">
        Draw()
       </samp>
       function
may be split into sub functions:
       <samp class="codeph">
        DrawThis()
       </samp>
       ,
       <samp class="codeph">
        DrawThat()
       </samp>
       ,
       <samp class="codeph">
        DrawTheOther()
       </samp>
       .
Each of these requires a corresponding
       <samp class="codeph">
        DrawThisNow()
       </samp>
       and/or
       <samp class="codeph">
        DrawThisDeferred()
       </samp>
       function.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-EDC0D6F1-61BC-552F-B56D-C32148ADECA3">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-EDC0D6F1-61BC-552F-B56D-C32148ADECA3">
        <!-- -->
       </a>
       CMyControl::Draw()
    {
    DrawThis() ;
    DrawThat() ;
    DrawTheOther() ;
    }
      </pre>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-E026186D-7B55-5AB5-9391-8587E3510D6D">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-E026186D-7B55-5AB5-9391-8587E3510D6D">
        <!-- -->
       </a>
       CMyControl::DrawThisNow()
    {
    ActivateGc() ;
    DrawThis() ;
    DeactivateGc() ;
    }
      </pre>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-AC723EE4-1482-59C5-9F13-CAE119C7800D">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-AC723EE4-1482-59C5-9F13-CAE119C7800D">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Handling events
      </h2>
      <p>
       The
Control Framework supports user interaction in two ways: key-press events
and pointer events. Both types of event arrive through the Window Server though
they each arrive in a slightly different way. Both are closely related to
the concept of 'focus' and the location of the cursor.
      </p>
      <p>
       <strong>
        Handling
key events
       </strong>
      </p>
      <p>
       Key events are delivered to the AppUi. The Window
Server channels them through the root window of its current window group which
maps to the AppUi foreground application. The AppUi offers each key event
to each of the controls on its control stack in priority order until one of
the controls 'consumes' it.
      </p>
      <p>
       To receive key events a control must implement
       <samp class="codeph">
        CCoeControl::OfferKeyEventL()
       </samp>
       .
If it handles the event it must return
       <samp class="codeph">
        EKeyWasConsumed
       </samp>
       : If
it doesn't it must return
       <samp class="codeph">
        EKeyWasNotConsumed
       </samp>
       so that the
next control on the stack receives it.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-448E9DF8-9D63-5BA4-94A7-4FB4B96A6DEA">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-448E9DF8-9D63-5BA4-94A7-4FB4B96A6DEA">
        <!-- -->
       </a>
       TKeyResponse CMyControl::OfferKeyEventL( const TKeyEvent&amp; aKeyEvent, TEventCode aType)
    {
    TKeyResponse returnValue = EKeyWasConsumed ;
    switch( aKeyEvent.iCode ) 
        {
        case EKeyEnter :
            // do stuff
            break ;
        case EKeyEscape :
            // do stuff :
            break ;

            ...
                
        default :
            // did not recognise key event
            returnValue = EKeyWasNotConsumed ;
            break ;
        }
    return returnValue ;
    }
      </pre>
      <p>
       The handling of key events will depend on the design
and purpose of the control itself. Compound controls might need to keep track
of an input
       <strong>
        focus
       </strong>
       , or
       <strong>
        cursor
       </strong>
       , and to pass key events amongst
its lodgers. Input into one lodger might have an effect on another - pressing
a navigation key might cause one control to lose the highlight and another
to gain it, pressing a number key might cause a text editor to grow which
might, in turn, require all of the components below it to shuffle downwards
and a scroll bar to become visible (which might also require some controls
to be laid out differently).
      </p>
      <p>
       <strong>
        Handling pointer events
       </strong>
      </p>
      <p>
       Pointer
events are slightly different as the position of the pointer, rather than
of the focus, is significant. The Window Server passes a pointer event to
the top-most visible window at the point of contact. The Framework uses the
functions
       <samp class="codeph">
        ProcessPointerEventL()
       </samp>
       and
       <samp class="codeph">
        HandlePointerEventL()
       </samp>
       to
work down the hierarchy. The Framework also uses the
       <a href="GUID-A2BF9AE8-CF42-3D94-8763-66DB11EDDA46.html">
        <span class="apiname">
         MCoeControlObserver
        </span>
       </a>
       and
focussing mechanisms to inform the observer of the controls that will be losing
and gaining the focus.
      </p>
      <p>
       <strong>
        Using the Control Observer Interface
       </strong>
      </p>
      <p>
       The
Control Framework facilitates this type of relationship between a container
and its lodgers with the
       <samp class="codeph">
        MCoeControlObserver
       </samp>
       interface. Typically
the container implements the interface and becomes the observer for each lodger
that can receive user input (focus). There is only one function in
       <samp class="codeph">
        MCoeControlObserver
       </samp>
       :
      </p>
      <pre class="codeblock">
       virtual void HandleControlEventL( CCoeControl *aControl, TCoeEvent aEventType ) = 0 ;
      </pre>
      <p>
       and it is called when an observed control calls
      </p>
      <pre class="codeblock">
       void CCoeControl::ReportEvent( MCoeControlObserver::TCoeEvent aEvent ) ;
      </pre>
      <p>
       A control can have only one observer (or none) so
       <samp class="codeph">
        ReportEvent()
       </samp>
       does
not need to specify an observer. An observer may observe any number of controls
so
       <samp class="codeph">
        HandleControlEventL()
       </samp>
       takes the observed control as a
parameter. The other piece of information passed to the observer is a
       <samp class="codeph">
        TCoeEvent
       </samp>
       .
      </p>
      <pre class="codeblock">
       enum TCoeEvent
    {
    EEventRequestExit,
    EEventRequestCancel,
    EEventRequestFocus,
    EEventPrepareFocusTransition,
    EEventStateChanged,
    EEventInteractionRefused
	 };
      </pre>
      <p>
       <samp class="codeph">
        CCoeControl
       </samp>
       also provides
       <samp class="codeph">
        IsFocused()
       </samp>
       ,
       <samp class="codeph">
        SetFocused()
       </samp>
       and
       <samp class="codeph">
        IsNonFocussing()
       </samp>
       . Note that Framework does not attempt to ensure exclusivity of focus, nor
does it give any visible indication of focus. It is up to the application
developer to ensure that only one control has the focus at a time, that the
focus is correctly transferred between controls, that only appropriate controls
receive the focus and that the focus is visible at all times.
      </p>
      <pre class="codeblock">
       void CContainer::HandleControlEventL(CCoeControl* aControl, TCoeEvent aEventType)
    {
	 switch (aEventType)
        {
		   case EEventRequestFocus:
			    {
			    if( !(aControl-&gt;IsFocussed()) )
				     {
				     aControl-&gt;SetFocus( ETrue ) ;
				     // remove focus from other controls
				     for ( Tint ii = 0 ; ii &lt; CountComponentControls() ; ii++ ) 
                     {
					       CCoeControl* ctl = ComponentControl( ii ) ;
					       if( ( ctl != aControl ) &amp;&amp; !( ctl-&gt;IsNonFocussing() ) )
						        {
						        aControl-&gt;SetFocus( EFalse ) ;
						        }
					       }
				      }
			     }
			     break;
	           ...
		     }
	    }
      </pre>
      <p>
       Control developers may implement
       <samp class="codeph">
        HandlePointerEventL()
       </samp>
       ,
which is a virtual function, to perform pointer event functionality. The implementation
must, however, call the base class function.
      </p>
      <p>
       Controls may modify their
pointer area, possibly if they appear non-rectangular or overlap. To do so
requires the addition of a hit test which describes a hit-test region. A hit-test
region may cover all or part of one or more controls. A hit for a control
is registered in the area covered by both the control and its associated hit
test.
      </p>
      <p>
       The diagram below represents three controls, each of which is
rectangular but which appears on the screen as a non-rectangular bitmap. Only
a hit on a bitmap area should register. This could be achieved by defining
a single hit-test region in the shape (and position) of the three blue areas
and associating it with each of the controls. The class that implements the
hit-test region must implement the MCoeControlHitTest interface.
      </p>
      <div class="fignone" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-5C856964-8553-543A-B7E2-8D5DCA9BF52C">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-5C856964-8553-543A-B7E2-8D5DCA9BF52C">
        <!-- -->
       </a>
       <span class="figcap">
        Figure 1.               Hit-test region example
       </span>
       <img src="GUID-CF34E1C9-48E5-5B91-A48E-C68E647116A0_d0e48128_href.png" />
      </div>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-D2AF9CEB-3072-5239-A157-D19852076CEF">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-D2AF9CEB-3072-5239-A157-D19852076CEF">
        <!-- -->
       </a>
       class MCoeControlHitTest
        ...
    public:
        virtual TBool HitRegionContains( const TPoint&amp; aPoint, const CCoeControl&amp; aControl ) const = 0;
      </pre>
      <p>
       A hit test is associated with a control using
       <samp class="codeph">
        CCoeControl::SetHitText()
       </samp>
       .
The base class implementation of
       <samp class="codeph">
        HandlePointerEventL()
       </samp>
       performs
the following test:
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-35C26C5B-A19A-528A-B5BE-B8177F81B05D">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-35C26C5B-A19A-528A-B5BE-B8177F81B05D">
        <!-- -->
       </a>
       ...
    const MCoeControlHitTest* hitTest = ctrl-&gt;HitTest() ;
    if( hitTest )
        {
        if( hitTest-&gt;HitRegionContains( aPointerEvent.iPosition, *ctrl ) &amp;&amp;
                        ctrl-&gt;Rect().Contains( aPointerEvent.iPosition ) )
      </pre>
      <p>
       Note
that this is performed by a container when deciding which lodger to pass the
event onto. This snippet also illustrates how a control can find where (
       <samp class="codeph">
        iPosition
       </samp>
       )
the pointer event actually occurred.
      </p>
      <p>
       Pointer support includes dragging
&amp; grabbing. See
       <a href="GUID-1FFA0073-3D83-388E-A824-08C31F90CC54.html">
        <span class="apiname">
         TPointerEvent
        </span>
       </a>
       .
      </p>
     </div>
     <div class="section" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-FE221E89-1817-5A73-8FBA-212FBC030766">
      <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-FE221E89-1817-5A73-8FBA-212FBC030766">
       <!-- -->
      </a>
      <h2 class="sectiontitle">
       Implementing
the Object Provider (MOP) interface
      </h2>
      <p>
       The
       <a href="GUID-F32E2F00-B68F-59B2-AABA-181E16354C86.html">
        Object
Provider mechanism
       </a>
       exists to allow a control to call a function on
another control in the hierarchy for which it does not have a reference. It
simply calls
       <samp class="codeph">
        MopGetObject()
       </samp>
       specifying the interface containing
the function. It may also call
       <samp class="codeph">
        MopGetObjectNoChaining()
       </samp>
       to
inquire of a specific object whether it supports the requested interface.
      </p>
      <p>
       Only
controls which wish to supply an interface require customisation. In order
to be identifiable an interface must have an associated UID. The following
code samples show how
       <a href="GUID-0DC77F9B-718A-31DF-B076-3C3F83378BF4.html">
        <span class="apiname">
         CEikAlignedControl
        </span>
       </a>
       implements and
supplies
       <samp class="codeph">
        MEikAlignedControl
       </samp>
       :
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-9926598F-163B-5ACF-B320-66B43D331E1A">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-9926598F-163B-5ACF-B320-66B43D331E1A">
        <!-- -->
       </a>
       class MEikAlignedControl
        ...
    public:
        DECLARE_TYPE_ID( 0x10A3D51B )  // Symbian allocated UID identifies this interface
        ...
      </pre>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-1C2FE28B-7A1F-5726-8690-50FBA8672A2C">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-1C2FE28B-7A1F-5726-8690-50FBA8672A2C">
        <!-- -->
       </a>
       class CEikAlignedControl : public CCoeControl, public MEikAlignedControl
    {
        ...
    private: //from CCoeControl
        IMPORT_C TTypeUid::Ptr MopSupplyObject( TTypeUid aId ) ;
        ...
      </pre>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-03CD8613-9C1D-556C-94B7-5D9A1C23FF83">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-03CD8613-9C1D-556C-94B7-5D9A1C23FF83">
        <!-- -->
       </a>
       EXPORT_C TTypeUid::Ptr CEikAlignedControl::MopSupplyObject( TTypeUid aId )
    {
    if( aId.iUid == MEikAlignedControl::ETypeId )
        return aId.MakePtr( static_cast&lt;MEikAlignedControl*&gt;( this ) ) ;

    return CCoeControl::MopSupplyObject( aId ) ; // must call base class!
    }
      </pre>
      <p>
       To get an interface from the object provider framework the
caller must use a pointer to the interface.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-CB641ADD-5AFE-5D72-A909-CD3F0C3BAA9A">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-CB641ADD-5AFE-5D72-A909-CD3F0C3BAA9A">
        <!-- -->
       </a>
       ...
    MEikAlignedControl* alignedControl = NULL ;
    MyControl-&gt;MopGetObject( alignedControl ) ;
    if ( alignedControl )
        {
        ... // etc.
      </pre>
      <p>
       To get an interface from a specific object
the caller may use the no-chaining function call.
      </p>
      <pre class="codeblock" id="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-AEB5EB12-6289-5DCB-BF07-71B8F7A67E33">
       <a name="GUID-B84FA223-3DFD-58C5-8CEF-C5AA73AA6290__GUID-AEB5EB12-6289-5DCB-BF07-71B8F7A67E33">
        <!-- -->
       </a>
       ...
    MEikAlignedControl* alignedControl = NULL ;
    aControl-&gt;MopGetObjectNoChaining( alignedControl ) ;
    if ( alignedControl )
        {
        ... // etc.
      </pre>
     </div>
    </div>
    <div>
     <div class="familylinks">
      <div class="parentlink">
       <strong>
        Parent topic:
       </strong>
       <a href="GUID-6C16417B-5B37-5310-B59A-750D971AA6D4.html">
        The UI Control Framework (CONE)
       </a>
      </div>
     </div>
    </div>
    <p class="copyright">Copyright &#169;2010 Nokia Corporation and/or its subsidiary(-ies).<br /> All rights
reserved. Unless otherwise stated, these materials are provided under the terms of the <a href=" http://www.eclipse.org/legal/epl-v10.html"> Eclipse Public License
v1.0</a>.</p> 
   </div>
  </div>
  <?php include_once (CURRENT_SKIN_PATH.'/sdl_footer.html'); ?>
 </body>
</html>